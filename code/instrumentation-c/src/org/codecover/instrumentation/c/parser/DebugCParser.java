/* Generated By:JavaCC: Do not edit this line. CParser.java */
package org.codecover.instrumentation.c.parser;

import java.util.*;
import org.codecover.instrumentation.c.syntaxtree.*;
import java.util.Vector;


public class DebugCParser implements CParserConstants {
   private Set<String> types = new HashSet();
   private Stack<Boolean> typedefParsingStack = new Stack();
   private boolean isType(String type)
   {
      return types.contains(type);
   }
   public void addType(String type)
   {
      types.add(type);
   }

  final public Constant Constant() throws ParseException {
    trace_call("Constant");
    try {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
      switch (jj_nt.kind) {
      case NUMBER:
        n2 = jj_consume_token(NUMBER);
                    n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
        break;
      case CHARACTER_LITERAL:
        n4 = jj_consume_token(CHARACTER_LITERAL);
                               n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     {if (true) return new Constant(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Constant");
    }
  }

  final public EnumerationConstant EnumerationConstant() throws ParseException {
    trace_call("EnumerationConstant");
    try {
   NodeToken n0;
   Token n1;
      n1 = jj_consume_token(IDENTIFIER);
                     n0 = JTBToolkit.makeNodeToken(n1);
     {if (true) return new EnumerationConstant(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("EnumerationConstant");
    }
  }

  final public StringLiteral StringLiteral() throws ParseException {
    trace_call("StringLiteral");
    try {
   NodeList n0 = new NodeList();
   NodeToken n1;
   Token n2;
      label_1:
      while (true) {
        n2 = jj_consume_token(STRING_LITERAL);
                            n1 = JTBToolkit.makeNodeToken(n2);
        n0.addNode(n1);
        switch (jj_nt.kind) {
        case STRING_LITERAL:
          ;
          break;
        default:
          jj_la1[1] = jj_gen;
          break label_1;
        }
      }
     n0.nodes.trimToSize();
     {if (true) return new StringLiteral(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("StringLiteral");
    }
  }

  final public PrimaryExpression PrimaryExpression() throws ParseException {
    trace_call("PrimaryExpression");
    try {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   Constant n3;
   StringLiteral n4;
   NodeSequence n5;
   NodeToken n6;
   Token n7;
   Expression n8;
   NodeToken n9;
   Token n10;
   GenericSelection n11;
      switch (jj_nt.kind) {
      case IDENTIFIER:
        n2 = jj_consume_token(IDENTIFIER);
                        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
        break;
      case NUMBER:
      case CHARACTER_LITERAL:
        n3 = Constant();
        n0 = new NodeChoice(n3, 1);
        break;
      case STRING_LITERAL:
        n4 = StringLiteral();
        n0 = new NodeChoice(n4, 2);
        break;
      case RBL:
        n5 = new NodeSequence(3);
        n7 = jj_consume_token(RBL);
               n6 = JTBToolkit.makeNodeToken(n7);
        n5.addNode(n6);
        n8 = Expression();
        n5.addNode(n8);
        n10 = jj_consume_token(RBR);
                n9 = JTBToolkit.makeNodeToken(n10);
        n5.addNode(n9);
        n0 = new NodeChoice(n5, 3);
        break;
      case GENERIC:
        n11 = GenericSelection();
        n0 = new NodeChoice(n11, 4);
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     {if (true) return new PrimaryExpression(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("PrimaryExpression");
    }
  }

  final public GenericSelection GenericSelection() throws ParseException {
    trace_call("GenericSelection");
    try {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   AssignmentExpression n4;
   NodeToken n5;
   Token n6;
   GenericAssocList n7;
   NodeToken n8;
   Token n9;
      n1 = jj_consume_token(GENERIC);
                  n0 = JTBToolkit.makeNodeToken(n1);
      n3 = jj_consume_token(RBL);
            n2 = JTBToolkit.makeNodeToken(n3);
      n4 = AssignmentExpression();
      n6 = jj_consume_token(COMMA);
            n5 = JTBToolkit.makeNodeToken(n6);
      n7 = GenericAssocList();
      n9 = jj_consume_token(RBR);
            n8 = JTBToolkit.makeNodeToken(n9);
     {if (true) return new GenericSelection(n0,n2,n4,n5,n7,n8);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("GenericSelection");
    }
  }

  final public GenericAssocList GenericAssocList() throws ParseException {
    trace_call("GenericAssocList");
    try {
   GenericAssociation n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   GenericAssociation n5;
      n0 = GenericAssociation();
      label_2:
      while (true) {
        switch (jj_nt.kind) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[3] = jj_gen;
          break label_2;
        }
        n2 = new NodeSequence(2);
        n4 = jj_consume_token(COMMA);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
        n5 = GenericAssociation();
        n2.addNode(n5);
        n1.addNode(n2);
      }
     n1.nodes.trimToSize();
     {if (true) return new GenericAssocList(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("GenericAssocList");
    }
  }

  final public GenericAssociation GenericAssociation() throws ParseException {
    trace_call("GenericAssociation");
    try {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   TypeName n3;
   NodeToken n4;
   Token n5;
   AssignmentExpression n6;
      switch (jj_nt.kind) {
      case DFAULT:
        n2 = jj_consume_token(DFAULT);
                       n1 = JTBToolkit.makeNodeToken(n2);
           n0 = new NodeChoice(n1, 0);
        break;
      default:
        jj_la1[4] = jj_gen;
        if (jj_2_1(1)) {
          n3 = TypeName();
           n0 = new NodeChoice(n3, 1);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      n5 = jj_consume_token(COLON);
            n4 = JTBToolkit.makeNodeToken(n5);
      n6 = AssignmentExpression();
     {if (true) return new GenericAssociation(n0,n4,n6);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("GenericAssociation");
    }
  }

  final public PostfixExpression PostfixExpression() throws ParseException {
    trace_call("PostfixExpression");
    try {
   NodeChoice n0;
   NodeSequence n1;
   NodeToken n2;
   Token n3;
   TypeName n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   InitializerList n9;
   NodeOptional n10 = new NodeOptional();
   NodeToken n11;
   Token n12;
   NodeToken n13;
   Token n14;
   NodeSequence n15;
   PrimaryExpression n16;
   NodeListOptional n17 = new NodeListOptional();
   NodeChoice n18;
   NodeSequence n19;
   NodeToken n20;
   Token n21;
   Expression n22;
   NodeToken n23;
   Token n24;
   NodeSequence n25;
   NodeToken n26;
   Token n27;
   NodeOptional n28;
   ArgumentExpressionList n29;
   NodeToken n30;
   Token n31;
   NodeSequence n32;
   NodeToken n33;
   Token n34;
   NodeToken n35;
   Token n36;
   NodeSequence n37;
   NodeToken n38;
   Token n39;
   NodeToken n40;
   Token n41;
   NodeToken n42;
   Token n43;
   NodeToken n44;
   Token n45;
      if (jj_2_3(2)) {
        n1 = new NodeSequence(8);
        n3 = jj_consume_token(RBL);
               n2 = JTBToolkit.makeNodeToken(n3);
        n1.addNode(n2);
        n4 = TypeName();
        n1.addNode(n4);
        n6 = jj_consume_token(RBR);
               n5 = JTBToolkit.makeNodeToken(n6);
        n1.addNode(n5);
        n8 = jj_consume_token(CBL);
               n7 = JTBToolkit.makeNodeToken(n8);
        n1.addNode(n7);
        n9 = InitializerList();
        n1.addNode(n9);
        switch (jj_nt.kind) {
        case COMMA:
          n12 = jj_consume_token(COMMA);
                   n11 = JTBToolkit.makeNodeToken(n12);
           n10.addNode(n11);
          break;
        default:
          jj_la1[5] = jj_gen;
          ;
        }
        n1.addNode(n10);
        n14 = jj_consume_token(CBR);
                n13 = JTBToolkit.makeNodeToken(n14);
        n1.addNode(n13);
        n0 = new NodeChoice(n1, 0);
      } else {
        switch (jj_nt.kind) {
        case NUMBER:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case GENERIC:
        case IDENTIFIER:
        case RBL:
        n15 = new NodeSequence(2);
          n16 = PrimaryExpression();
        n15.addNode(n16);
          label_3:
          while (true) {
            switch (jj_nt.kind) {
            case INC:
            case DEC:
            case RBL:
            case SBL:
            case DOT:
            case ARROW:
              ;
              break;
            default:
              jj_la1[6] = jj_gen;
              break label_3;
            }
           n28 = new NodeOptional();
            switch (jj_nt.kind) {
            case SBL:
              n19 = new NodeSequence(3);
              n21 = jj_consume_token(SBL);
                      n20 = JTBToolkit.makeNodeToken(n21);
              n19.addNode(n20);
              n22 = Expression();
              n19.addNode(n22);
              n24 = jj_consume_token(SBR);
                      n23 = JTBToolkit.makeNodeToken(n24);
              n19.addNode(n23);
              n18 = new NodeChoice(n19, 0);
              break;
            case RBL:
              n25 = new NodeSequence(3);
              n27 = jj_consume_token(RBL);
                      n26 = JTBToolkit.makeNodeToken(n27);
              n25.addNode(n26);
              if (jj_2_2(2147483647)) {
                n29 = ArgumentExpressionList();
                 n28.addNode(n29);
              } else {
                ;
              }
              n25.addNode(n28);
              n31 = jj_consume_token(RBR);
                      n30 = JTBToolkit.makeNodeToken(n31);
              n25.addNode(n30);
              n18 = new NodeChoice(n25, 1);
              break;
            case DOT:
              n32 = new NodeSequence(2);
              n34 = jj_consume_token(DOT);
                      n33 = JTBToolkit.makeNodeToken(n34);
              n32.addNode(n33);
              n36 = jj_consume_token(IDENTIFIER);
                               n35 = JTBToolkit.makeNodeToken(n36);
              n32.addNode(n35);
              n18 = new NodeChoice(n32, 2);
              break;
            case ARROW:
              n37 = new NodeSequence(2);
              n39 = jj_consume_token(ARROW);
                               n38 = JTBToolkit.makeNodeToken(n39);
              n37.addNode(n38);
              n41 = jj_consume_token(IDENTIFIER);
                               n40 = JTBToolkit.makeNodeToken(n41);
              n37.addNode(n40);
              n18 = new NodeChoice(n37, 3);
              break;
            case INC:
              n43 = jj_consume_token(INC);
                       n42 = JTBToolkit.makeNodeToken(n43);
              n18 = new NodeChoice(n42, 4);
              break;
            case DEC:
              n45 = jj_consume_token(DEC);
                       n44 = JTBToolkit.makeNodeToken(n45);
              n18 = new NodeChoice(n44, 5);
              break;
            default:
              jj_la1[7] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
           n17.addNode(n18);
          }
        n17.nodes.trimToSize();
        n15.addNode(n17);
        n0 = new NodeChoice(n15, 1);
          break;
        default:
          jj_la1[8] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
     {if (true) return new PostfixExpression(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("PostfixExpression");
    }
  }

  final public ArgumentExpressionList ArgumentExpressionList() throws ParseException {
    trace_call("ArgumentExpressionList");
    try {
   AssignmentExpression n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   AssignmentExpression n5;
      n0 = AssignmentExpression();
      label_4:
      while (true) {
        switch (jj_nt.kind) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_4;
        }
        n2 = new NodeSequence(2);
        n4 = jj_consume_token(COMMA);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
        n5 = AssignmentExpression();
        n2.addNode(n5);
        n1.addNode(n2);
      }
     n1.nodes.trimToSize();
     {if (true) return new ArgumentExpressionList(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ArgumentExpressionList");
    }
  }

  final public UnaryExpression UnaryExpression() throws ParseException {
    trace_call("UnaryExpression");
    try {
   NodeChoice n0;
   PostfixExpression n1;
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   UnaryExpression n5;
   NodeSequence n6;
   NodeToken n7;
   Token n8;
   UnaryExpression n9;
   NodeSequence n10;
   UnaryOperator n11;
   CastExpression n12;
   NodeSequence n13;
   NodeToken n14;
   Token n15;
   NodeChoice n16;
   NodeSequence n17;
   NodeToken n18;
   Token n19;
   TypeName n20;
   NodeToken n21;
   Token n22;
   UnaryExpression n23;
   NodeSequence n24;
   NodeToken n25;
   Token n26;
   NodeToken n27;
   Token n28;
   TypeName n29;
   NodeToken n30;
   Token n31;
      if (jj_2_5(3)) {
        n1 = PostfixExpression();
        n0 = new NodeChoice(n1, 0);
      } else {
        switch (jj_nt.kind) {
        case INC:
        n2 = new NodeSequence(2);
          n4 = jj_consume_token(INC);
                n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
          n5 = UnaryExpression();
        n2.addNode(n5);
        n0 = new NodeChoice(n2, 1);
          break;
        case DEC:
        n6 = new NodeSequence(2);
          n8 = jj_consume_token(DEC);
                n7 = JTBToolkit.makeNodeToken(n8);
        n6.addNode(n7);
          n9 = UnaryExpression();
        n6.addNode(n9);
        n0 = new NodeChoice(n6, 2);
          break;
        case STAR:
        case PLUS:
        case MINUS:
        case EXCL:
        case AMP:
        case TILDE:
        n10 = new NodeSequence(2);
          n11 = UnaryOperator();
        n10.addNode(n11);
          n12 = CastExpression();
        n10.addNode(n12);
        n0 = new NodeChoice(n10, 3);
          break;
        case SIZEOF:
        n13 = new NodeSequence(2);
          n15 = jj_consume_token(SIZEOF);
                     n14 = JTBToolkit.makeNodeToken(n15);
        n13.addNode(n14);
          if (jj_2_4(3)) {
              n17 = new NodeSequence(4);
            n19 = jj_consume_token(RBL);
                      n18 = JTBToolkit.makeNodeToken(n19);
              n17.addNode(n18);
            n20 = TypeName();
              n17.addNode(n20);
            n22 = jj_consume_token(RBR);
                      n21 = JTBToolkit.makeNodeToken(n22);
              n17.addNode(n21);
              n16 = new NodeChoice(n17, 0);
          } else {
            switch (jj_nt.kind) {
            case NUMBER:
            case CHARACTER_LITERAL:
            case STRING_LITERAL:
            case ALIGNOF:
            case SIZEOF:
            case GENERIC:
            case IDENTIFIER:
            case INC:
            case DEC:
            case RBL:
            case STAR:
            case PLUS:
            case MINUS:
            case EXCL:
            case AMP:
            case TILDE:
              n23 = UnaryExpression();
              n16 = new NodeChoice(n23, 1);
              break;
            default:
              jj_la1[10] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        n13.addNode(n16);
        n0 = new NodeChoice(n13, 4);
          break;
        case ALIGNOF:
        n24 = new NodeSequence(4);
          n26 = jj_consume_token(ALIGNOF);
                      n25 = JTBToolkit.makeNodeToken(n26);
        n24.addNode(n25);
          n28 = jj_consume_token(RBL);
                n27 = JTBToolkit.makeNodeToken(n28);
        n24.addNode(n27);
          n29 = TypeName();
        n24.addNode(n29);
          n31 = jj_consume_token(RBR);
                n30 = JTBToolkit.makeNodeToken(n31);
        n24.addNode(n30);
        n0 = new NodeChoice(n24, 5);
          break;
        default:
          jj_la1[11] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
     {if (true) return new UnaryExpression(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("UnaryExpression");
    }
  }

  final public UnaryOperator UnaryOperator() throws ParseException {
    trace_call("UnaryOperator");
    try {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
      switch (jj_nt.kind) {
      case AMP:
        n2 = jj_consume_token(AMP);
                  n1 = JTBToolkit.makeNodeToken(n2);
           n0 = new NodeChoice(n1, 0);
        break;
      case STAR:
        n4 = jj_consume_token(STAR);
                  n3 = JTBToolkit.makeNodeToken(n4);
           n0 = new NodeChoice(n3, 1);
        break;
      case PLUS:
        n6 = jj_consume_token(PLUS);
                  n5 = JTBToolkit.makeNodeToken(n6);
           n0 = new NodeChoice(n5, 2);
        break;
      case MINUS:
        n8 = jj_consume_token(MINUS);
                  n7 = JTBToolkit.makeNodeToken(n8);
           n0 = new NodeChoice(n7, 3);
        break;
      case TILDE:
        n10 = jj_consume_token(TILDE);
                   n9 = JTBToolkit.makeNodeToken(n10);
           n0 = new NodeChoice(n9, 4);
        break;
      case EXCL:
        n12 = jj_consume_token(EXCL);
                   n11 = JTBToolkit.makeNodeToken(n12);
           n0 = new NodeChoice(n11, 5);
        break;
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     {if (true) return new UnaryOperator(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("UnaryOperator");
    }
  }

  final public CastExpression CastExpression() throws ParseException {
    trace_call("CastExpression");
    try {
   NodeChoice n0;
   NodeSequence n1;
   NodeToken n2;
   Token n3;
   TypeName n4;
   NodeToken n5;
   Token n6;
   CastExpression n7;
   UnaryExpression n8;
      if (jj_2_6(2147483647)) {
           n1 = new NodeSequence(5);
        n3 = jj_consume_token(RBL);
                  n2 = JTBToolkit.makeNodeToken(n3);
           n1.addNode(n2);
        n4 = TypeName();
           n1.addNode(n4);
        n6 = jj_consume_token(RBR);
                  n5 = JTBToolkit.makeNodeToken(n6);
           n1.addNode(n5);
        n7 = CastExpression();
           n1.addNode(n7);
           n0 = new NodeChoice(n1, 0);
      } else {
        switch (jj_nt.kind) {
        case NUMBER:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case ALIGNOF:
        case SIZEOF:
        case GENERIC:
        case IDENTIFIER:
        case INC:
        case DEC:
        case RBL:
        case STAR:
        case PLUS:
        case MINUS:
        case EXCL:
        case AMP:
        case TILDE:
          n8 = UnaryExpression();
           n0 = new NodeChoice(n8, 1);
          break;
        default:
          jj_la1[13] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
     {if (true) return new CastExpression(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("CastExpression");
    }
  }

  final public MultiplicativeExpression MultiplicativeExpression() throws ParseException {
    trace_call("MultiplicativeExpression");
    try {
   CastExpression n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeChoice n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   NodeToken n8;
   Token n9;
   MultiplicativeExpression n10;
      n0 = CastExpression();
      switch (jj_nt.kind) {
      case STAR:
      case SLASH:
      case MOD:
        n2 = new NodeSequence(2);
        switch (jj_nt.kind) {
        case STAR:
          n5 = jj_consume_token(STAR);
                     n4 = JTBToolkit.makeNodeToken(n5);
              n3 = new NodeChoice(n4, 0);
          break;
        case SLASH:
          n7 = jj_consume_token(SLASH);
                     n6 = JTBToolkit.makeNodeToken(n7);
              n3 = new NodeChoice(n6, 1);
          break;
        case MOD:
          n9 = jj_consume_token(MOD);
                     n8 = JTBToolkit.makeNodeToken(n9);
              n3 = new NodeChoice(n8, 2);
          break;
        default:
          jj_la1[14] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        n2.addNode(n3);
        n10 = MultiplicativeExpression();
        n2.addNode(n10);
        n1.addNode(n2);
        break;
      default:
        jj_la1[15] = jj_gen;
        ;
      }
     {if (true) return new MultiplicativeExpression(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("MultiplicativeExpression");
    }
  }

  final public AdditiveExpression AdditiveExpression() throws ParseException {
    trace_call("AdditiveExpression");
    try {
   MultiplicativeExpression n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeChoice n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   AdditiveExpression n8;
      n0 = MultiplicativeExpression();
      switch (jj_nt.kind) {
      case PLUS:
      case MINUS:
        n2 = new NodeSequence(2);
        switch (jj_nt.kind) {
        case PLUS:
          n5 = jj_consume_token(PLUS);
                     n4 = JTBToolkit.makeNodeToken(n5);
              n3 = new NodeChoice(n4, 0);
          break;
        case MINUS:
          n7 = jj_consume_token(MINUS);
                     n6 = JTBToolkit.makeNodeToken(n7);
              n3 = new NodeChoice(n6, 1);
          break;
        default:
          jj_la1[16] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        n2.addNode(n3);
        n8 = AdditiveExpression();
        n2.addNode(n8);
        n1.addNode(n2);
        break;
      default:
        jj_la1[17] = jj_gen;
        ;
      }
     {if (true) return new AdditiveExpression(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("AdditiveExpression");
    }
  }

  final public ShiftExpression ShiftExpression() throws ParseException {
    trace_call("ShiftExpression");
    try {
   AdditiveExpression n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeChoice n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   ShiftExpression n8;
      n0 = AdditiveExpression();
      switch (jj_nt.kind) {
      case LSH:
      case RSH:
        n2 = new NodeSequence(2);
        switch (jj_nt.kind) {
        case LSH:
          n5 = jj_consume_token(LSH);
                            n4 = JTBToolkit.makeNodeToken(n5);
              n3 = new NodeChoice(n4, 0);
          break;
        case RSH:
          n7 = jj_consume_token(RSH);
                            n6 = JTBToolkit.makeNodeToken(n7);
              n3 = new NodeChoice(n6, 1);
          break;
        default:
          jj_la1[18] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        n2.addNode(n3);
        n8 = ShiftExpression();
        n2.addNode(n8);
        n1.addNode(n2);
        break;
      default:
        jj_la1[19] = jj_gen;
        ;
      }
     {if (true) return new ShiftExpression(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ShiftExpression");
    }
  }

  final public RelationalExpression RelationalExpression() throws ParseException {
    trace_call("RelationalExpression");
    try {
   ShiftExpression n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeChoice n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   NodeToken n8;
   Token n9;
   NodeToken n10;
   Token n11;
   RelationalExpression n12;
      n0 = ShiftExpression();
      switch (jj_nt.kind) {
      case LESS:
      case GREATER:
      case LE:
      case GE:
        n2 = new NodeSequence(2);
        switch (jj_nt.kind) {
        case LESS:
          n5 = jj_consume_token(LESS);
                     n4 = JTBToolkit.makeNodeToken(n5);
              n3 = new NodeChoice(n4, 0);
          break;
        case GREATER:
          n7 = jj_consume_token(GREATER);
                     n6 = JTBToolkit.makeNodeToken(n7);
              n3 = new NodeChoice(n6, 1);
          break;
        case LE:
          n9 = jj_consume_token(LE);
                           n8 = JTBToolkit.makeNodeToken(n9);
              n3 = new NodeChoice(n8, 2);
          break;
        case GE:
          n11 = jj_consume_token(GE);
                            n10 = JTBToolkit.makeNodeToken(n11);
              n3 = new NodeChoice(n10, 3);
          break;
        default:
          jj_la1[20] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        n2.addNode(n3);
        n12 = RelationalExpression();
        n2.addNode(n12);
        n1.addNode(n2);
        break;
      default:
        jj_la1[21] = jj_gen;
        ;
      }
     {if (true) return new RelationalExpression(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("RelationalExpression");
    }
  }

  final public EqualityExpression EqualityExpression() throws ParseException {
    trace_call("EqualityExpression");
    try {
   RelationalExpression n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeChoice n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   EqualityExpression n8;
      n0 = RelationalExpression();
      switch (jj_nt.kind) {
      case EQ:
      case NE:
        n2 = new NodeSequence(2);
        switch (jj_nt.kind) {
        case EQ:
          n5 = jj_consume_token(EQ);
                           n4 = JTBToolkit.makeNodeToken(n5);
              n3 = new NodeChoice(n4, 0);
          break;
        case NE:
          n7 = jj_consume_token(NE);
                           n6 = JTBToolkit.makeNodeToken(n7);
              n3 = new NodeChoice(n6, 1);
          break;
        default:
          jj_la1[22] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        n2.addNode(n3);
        n8 = EqualityExpression();
        n2.addNode(n8);
        n1.addNode(n2);
        break;
      default:
        jj_la1[23] = jj_gen;
        ;
      }
     {if (true) return new EqualityExpression(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("EqualityExpression");
    }
  }

  final public ANDExpression ANDExpression() throws ParseException {
    trace_call("ANDExpression");
    try {
   EqualityExpression n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   ANDExpression n5;
      n0 = EqualityExpression();
      switch (jj_nt.kind) {
      case AMP:
        n2 = new NodeSequence(2);
        n4 = jj_consume_token(AMP);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
        n5 = ANDExpression();
        n2.addNode(n5);
        n1.addNode(n2);
        break;
      default:
        jj_la1[24] = jj_gen;
        ;
      }
     {if (true) return new ANDExpression(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ANDExpression");
    }
  }

  final public ExclusiveORExpression ExclusiveORExpression() throws ParseException {
    trace_call("ExclusiveORExpression");
    try {
   ANDExpression n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   ExclusiveORExpression n5;
      n0 = ANDExpression();
      switch (jj_nt.kind) {
      case CARE:
        n2 = new NodeSequence(2);
        n4 = jj_consume_token(CARE);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
        n5 = ExclusiveORExpression();
        n2.addNode(n5);
        n1.addNode(n2);
        break;
      default:
        jj_la1[25] = jj_gen;
        ;
      }
     {if (true) return new ExclusiveORExpression(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ExclusiveORExpression");
    }
  }

  final public InclusiveORExpression InclusiveORExpression() throws ParseException {
    trace_call("InclusiveORExpression");
    try {
   ExclusiveORExpression n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   InclusiveORExpression n5;
      n0 = ExclusiveORExpression();
      switch (jj_nt.kind) {
      case PIPE:
        n2 = new NodeSequence(2);
        n4 = jj_consume_token(PIPE);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
        n5 = InclusiveORExpression();
        n2.addNode(n5);
        n1.addNode(n2);
        break;
      default:
        jj_la1[26] = jj_gen;
        ;
      }
     {if (true) return new InclusiveORExpression(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("InclusiveORExpression");
    }
  }

  final public LogicalANDExpression LogicalANDExpression() throws ParseException {
    trace_call("LogicalANDExpression");
    try {
   InclusiveORExpression n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   LogicalANDExpression n5;
      n0 = InclusiveORExpression();
      switch (jj_nt.kind) {
      case LAND:
        n2 = new NodeSequence(2);
        n4 = jj_consume_token(LAND);
                n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
        n5 = LogicalANDExpression();
        n2.addNode(n5);
        n1.addNode(n2);
        break;
      default:
        jj_la1[27] = jj_gen;
        ;
      }
     {if (true) return new LogicalANDExpression(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("LogicalANDExpression");
    }
  }

  final public LogicalORExpression LogicalORExpression() throws ParseException {
    trace_call("LogicalORExpression");
    try {
   LogicalANDExpression n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   LogicalORExpression n5;
      n0 = LogicalANDExpression();
      switch (jj_nt.kind) {
      case LOR:
        n2 = new NodeSequence(2);
        n4 = jj_consume_token(LOR);
                n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
        n5 = LogicalORExpression();
        n2.addNode(n5);
        n1.addNode(n2);
        break;
      default:
        jj_la1[28] = jj_gen;
        ;
      }
     {if (true) return new LogicalORExpression(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("LogicalORExpression");
    }
  }

  final public ConditionalExpression ConditionalExpression() throws ParseException {
    trace_call("ConditionalExpression");
    try {
   LogicalORExpression n0;
   NodeOptional n1 = new NodeOptional();
   ConditionalExpressionRightSide n2;
      n0 = LogicalORExpression();
      switch (jj_nt.kind) {
      case QEM:
        n2 = ConditionalExpressionRightSide();
        n1.addNode(n2);
        break;
      default:
        jj_la1[29] = jj_gen;
        ;
      }
     {if (true) return new ConditionalExpression(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ConditionalExpression");
    }
  }

  final public ConditionalExpressionRightSide ConditionalExpressionRightSide() throws ParseException {
    trace_call("ConditionalExpressionRightSide");
    try {
   NodeToken n0;
   Token n1;
   Expression n2;
   NodeToken n3;
   Token n4;
   ConditionalExpression n5;
      n1 = jj_consume_token(QEM);
            n0 = JTBToolkit.makeNodeToken(n1);
      n2 = Expression();
      n4 = jj_consume_token(COLON);
            n3 = JTBToolkit.makeNodeToken(n4);
      n5 = ConditionalExpression();
     {if (true) return new ConditionalExpressionRightSide(n0,n2,n3,n5);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ConditionalExpressionRightSide");
    }
  }

  final public AssignmentExpression AssignmentExpression() throws ParseException {
    trace_call("AssignmentExpression");
    try {
   NodeChoice n0;
   NodeSequence n1;
   UnaryExpression n2;
   AssignmentOperator n3;
   AssignmentExpression n4;
   ConditionalExpression n5;
      if (jj_2_7(2147483647)) {
        n1 = new NodeSequence(4);
        n2 = UnaryExpression();
        n1.addNode(n2);
        n3 = AssignmentOperator();
        n1.addNode(n3);
        n4 = AssignmentExpression();
        n1.addNode(n4);
        n0 = new NodeChoice(n1, 0);
      } else {
        switch (jj_nt.kind) {
        case NUMBER:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case ALIGNOF:
        case SIZEOF:
        case GENERIC:
        case IDENTIFIER:
        case INC:
        case DEC:
        case RBL:
        case STAR:
        case PLUS:
        case MINUS:
        case EXCL:
        case AMP:
        case TILDE:
          n5 = ConditionalExpression();
        n0 = new NodeChoice(n5, 1);
          break;
        default:
          jj_la1[30] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
     {if (true) return new AssignmentExpression(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("AssignmentExpression");
    }
  }

  final public AssignmentOperator AssignmentOperator() throws ParseException {
    trace_call("AssignmentOperator");
    try {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
   NodeToken n13;
   Token n14;
   NodeToken n15;
   Token n16;
   NodeToken n17;
   Token n18;
   NodeToken n19;
   Token n20;
   NodeToken n21;
   Token n22;
      switch (jj_nt.kind) {
      case ASSIGNMENT:
        n2 = jj_consume_token(ASSIGNMENT);
               n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0);
        break;
      case MULT_EQ:
        n4 = jj_consume_token(MULT_EQ);
                          n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1);
        break;
      case DIV_EQ:
        n6 = jj_consume_token(DIV_EQ);
                         n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2);
        break;
      case MOD_EQ:
        n8 = jj_consume_token(MOD_EQ);
                         n7 = JTBToolkit.makeNodeToken(n8);
        n0 = new NodeChoice(n7, 3);
        break;
      case PLUS_EQ:
        n10 = jj_consume_token(PLUS_EQ);
                           n9 = JTBToolkit.makeNodeToken(n10);
        n0 = new NodeChoice(n9, 4);
        break;
      case SUB_EQ:
        n12 = jj_consume_token(SUB_EQ);
                          n11 = JTBToolkit.makeNodeToken(n12);
        n0 = new NodeChoice(n11, 5);
        break;
      case LSH_EQ:
        n14 = jj_consume_token(LSH_EQ);
                           n13 = JTBToolkit.makeNodeToken(n14);
        n0 = new NodeChoice(n13, 6);
        break;
      case RSH_EQ:
        n16 = jj_consume_token(RSH_EQ);
                           n15 = JTBToolkit.makeNodeToken(n16);
        n0 = new NodeChoice(n15, 7);
        break;
      case AND_EQ:
        n18 = jj_consume_token(AND_EQ);
                          n17 = JTBToolkit.makeNodeToken(n18);
        n0 = new NodeChoice(n17, 8);
        break;
      case XOR_EQ:
        n20 = jj_consume_token(XOR_EQ);
                          n19 = JTBToolkit.makeNodeToken(n20);
        n0 = new NodeChoice(n19, 9);
        break;
      case OR_EQ:
        n22 = jj_consume_token(OR_EQ);
                         n21 = JTBToolkit.makeNodeToken(n22);
        n0 = new NodeChoice(n21, 10);
        break;
      default:
        jj_la1[31] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     {if (true) return new AssignmentOperator(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("AssignmentOperator");
    }
  }

  final public Expression Expression() throws ParseException {
    trace_call("Expression");
    try {
   AssignmentExpression n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   AssignmentExpression n5;
      n0 = AssignmentExpression();
      label_5:
      while (true) {
        switch (jj_nt.kind) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[32] = jj_gen;
          break label_5;
        }
        n2 = new NodeSequence(2);
        n4 = jj_consume_token(COMMA);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
        n5 = AssignmentExpression();
        n2.addNode(n5);
        n1.addNode(n2);
      }
     n1.nodes.trimToSize();
     {if (true) return new Expression(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Expression");
    }
  }

  final public ConstantExpression ConstantExpression() throws ParseException {
    trace_call("ConstantExpression");
    try {
   ConditionalExpression n0;
      n0 = ConditionalExpression();
     {if (true) return new ConstantExpression(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ConstantExpression");
    }
  }

  final public Declaration Declaration() throws ParseException {
    trace_call("Declaration");
    try {
   NodeChoice n0;
   NodeSequence n1;
   DeclarationSpecifiers n2;
   NodeOptional n3 = new NodeOptional();
   InitDeclaratorList n4;
   NodeToken n5;
   Token n6;
   Static_AssertDeclaration n7;
      if (jj_2_8(1)) {
           n1 = new NodeSequence(3);
        n2 = DeclarationSpecifiers();
           n1.addNode(n2);
        switch (jj_nt.kind) {
        case IDENTIFIER:
        case RBL:
        case STAR:
          n4 = InitDeclaratorList();
              n3.addNode(n4);
          break;
        default:
          jj_la1[33] = jj_gen;
          ;
        }
           n1.addNode(n3);
        n6 = jj_consume_token(SEMICOLON);
                  n5 = JTBToolkit.makeNodeToken(n6);
           n1.addNode(n5);
           n0 = new NodeChoice(n1, 0);
      } else {
        switch (jj_nt.kind) {
        case STATICASSERT:
          n7 = Static_AssertDeclaration();
           n0 = new NodeChoice(n7, 1);
          break;
        default:
          jj_la1[34] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
     {if (true) return new Declaration(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Declaration");
    }
  }

  final public DeclarationSpecifiers DeclarationSpecifiers() throws ParseException {
    trace_call("DeclarationSpecifiers");
    try {
   NodeChoice n0;
   NodeSequence n1;
   StorageClassSpecifier n2;
   NodeOptional n3 = new NodeOptional();
   DeclarationSpecifiers n4;
   NodeSequence n5;
   TypeSpecifier n6;
   NodeOptional n7 = new NodeOptional();
   DeclarationSpecifiers n8;
   NodeSequence n9;
   TypeQualifier n10;
   NodeOptional n11 = new NodeOptional();
   DeclarationSpecifiers n12;
   NodeSequence n13;
   FunctionSpecifier n14;
   NodeOptional n15 = new NodeOptional();
   DeclarationSpecifiers n16;
   NodeSequence n17;
   AlignmentSpecifier n18;
   NodeOptional n19 = new NodeOptional();
   DeclarationSpecifiers n20;
      switch (jj_nt.kind) {
      case AUTO:
      case EXTERN:
      case REGISTER:
      case STATIC:
      case TYPEDEF:
      case THREADLOCAL:
        n1 = new NodeSequence(2);
        n2 = StorageClassSpecifier();
        n1.addNode(n2);
        if (jj_2_9(2147483647)) {
          n4 = DeclarationSpecifiers();
           n3.addNode(n4);
        } else {
          ;
        }
        n1.addNode(n3);
        n0 = new NodeChoice(n1, 0);
        break;
      default:
        jj_la1[35] = jj_gen;
        if (jj_2_14(2)) {
        n5 = new NodeSequence(3);
          n6 = TypeSpecifier();
        n5.addNode(n6);
          if (jj_2_10(2147483647)) {
            n8 = DeclarationSpecifiers();
           n7.addNode(n8);
          } else {
            ;
          }
        n5.addNode(n7);
        n0 = new NodeChoice(n5, 1);
        } else {
          switch (jj_nt.kind) {
          case CONST:
          case RESTRICT:
          case VOLATILE:
          case ATOMIC:
        n9 = new NodeSequence(2);
            n10 = TypeQualifier();
        n9.addNode(n10);
            if (jj_2_11(2147483647)) {
              n12 = DeclarationSpecifiers();
           n11.addNode(n12);
            } else {
              ;
            }
        n9.addNode(n11);
        n0 = new NodeChoice(n9, 2);
            break;
          case INLINE:
          case NORETURN:
        n13 = new NodeSequence(2);
            n14 = FunctionSpecifier();
        n13.addNode(n14);
            if (jj_2_12(2147483647)) {
              n16 = DeclarationSpecifiers();
           n15.addNode(n16);
            } else {
              ;
            }
        n13.addNode(n15);
        n0 = new NodeChoice(n13, 3);
            break;
          case ALIGNAS:
        n17 = new NodeSequence(2);
            n18 = AlignmentSpecifier();
        n17.addNode(n18);
            if (jj_2_13(2147483647)) {
              n20 = DeclarationSpecifiers();
           n19.addNode(n20);
            } else {
              ;
            }
        n17.addNode(n19);
        n0 = new NodeChoice(n17, 4);
            break;
          default:
            jj_la1[36] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
     {if (true) return new DeclarationSpecifiers(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("DeclarationSpecifiers");
    }
  }

  final public InitDeclaratorList InitDeclaratorList() throws ParseException {
    trace_call("InitDeclaratorList");
    try {
   InitDeclarator n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   InitDeclarator n5;
      n0 = InitDeclarator();
      label_6:
      while (true) {
        switch (jj_nt.kind) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[37] = jj_gen;
          break label_6;
        }
        n2 = new NodeSequence(2);
        n4 = jj_consume_token(COMMA);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
        n5 = InitDeclarator();
        n2.addNode(n5);
        n1.addNode(n2);
      }
     n1.nodes.trimToSize();
      if ( !(typedefParsingStack.empty()) && (typedefParsingStack.peek()) )
      {
         typedefParsingStack.pop();
      }
     {if (true) return new InitDeclaratorList(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("InitDeclaratorList");
    }
  }

  final public InitDeclarator InitDeclarator() throws ParseException {
    trace_call("InitDeclarator");
    try {
   Declarator n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   Initializer n5;
      n0 = Declarator();
      switch (jj_nt.kind) {
      case ASSIGNMENT:
        n2 = new NodeSequence(2);
        n4 = jj_consume_token(ASSIGNMENT);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
        n5 = Initializer();
        n2.addNode(n5);
        n1.addNode(n2);
        break;
      default:
        jj_la1[38] = jj_gen;
        ;
      }
     {if (true) return new InitDeclarator(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("InitDeclarator");
    }
  }

  final public StorageClassSpecifier StorageClassSpecifier() throws ParseException {
    trace_call("StorageClassSpecifier");
    try {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
      switch (jj_nt.kind) {
      case EXTERN:
        n2 = jj_consume_token(EXTERN);
                       n1 = JTBToolkit.makeNodeToken(n2);
           n0 = new NodeChoice(n1, 0);
        break;
      case STATIC:
        n4 = jj_consume_token(STATIC);
                       n3 = JTBToolkit.makeNodeToken(n4);
           n0 = new NodeChoice(n3, 1);
        break;
      case THREADLOCAL:
        n6 = jj_consume_token(THREADLOCAL);
                            n5 = JTBToolkit.makeNodeToken(n6);
           n0 = new NodeChoice(n5, 2);
        break;
      case AUTO:
        n8 = jj_consume_token(AUTO);
                     n7 = JTBToolkit.makeNodeToken(n8);
           n0 = new NodeChoice(n7, 3);
        break;
      case REGISTER:
        n10 = jj_consume_token(REGISTER);
                          n9 = JTBToolkit.makeNodeToken(n10);
           n0 = new NodeChoice(n9, 4);
        break;
      case TYPEDEF:
        n12 = jj_consume_token(TYPEDEF);
                         n11 = JTBToolkit.makeNodeToken(n12);
            typedefParsingStack.push(true);
           n0 = new NodeChoice(n11, 5);
        break;
      default:
        jj_la1[39] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     {if (true) return new StorageClassSpecifier(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("StorageClassSpecifier");
    }
  }

  final public TypeSpecifier TypeSpecifier() throws ParseException {
    trace_call("TypeSpecifier");
    try {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
   NodeToken n13;
   Token n14;
   NodeToken n15;
   Token n16;
   NodeToken n17;
   Token n18;
   NodeToken n19;
   Token n20;
   NodeToken n21;
   Token n22;
   AtomicSpecifier n23;
   StructOrUnionSpecifier n24;
   EnumSpecifier n25;
   TypedefName n26;
      switch (jj_nt.kind) {
      case VOID:
        n2 = jj_consume_token(VOID);
                     n1 = JTBToolkit.makeNodeToken(n2);
           n0 = new NodeChoice(n1, 0);
        break;
      case CHAR:
        n4 = jj_consume_token(CHAR);
                     n3 = JTBToolkit.makeNodeToken(n4);
           n0 = new NodeChoice(n3, 1);
        break;
      case SHORT:
        n6 = jj_consume_token(SHORT);
                      n5 = JTBToolkit.makeNodeToken(n6);
           n0 = new NodeChoice(n5, 2);
        break;
      case INT:
        n8 = jj_consume_token(INT);
                    n7 = JTBToolkit.makeNodeToken(n8);
           n0 = new NodeChoice(n7, 3);
        break;
      case LONG:
        n10 = jj_consume_token(LONG);
                      n9 = JTBToolkit.makeNodeToken(n10);
           n0 = new NodeChoice(n9, 4);
        break;
      case FLOAT:
        n12 = jj_consume_token(FLOAT);
                       n11 = JTBToolkit.makeNodeToken(n12);
           n0 = new NodeChoice(n11, 5);
        break;
      case DOUBLE:
        n14 = jj_consume_token(DOUBLE);
                        n13 = JTBToolkit.makeNodeToken(n14);
           n0 = new NodeChoice(n13, 6);
        break;
      case SIGNED:
        n16 = jj_consume_token(SIGNED);
                        n15 = JTBToolkit.makeNodeToken(n16);
           n0 = new NodeChoice(n15, 7);
        break;
      case UNSIGNED:
        n18 = jj_consume_token(UNSIGNED);
                          n17 = JTBToolkit.makeNodeToken(n18);
           n0 = new NodeChoice(n17, 8);
        break;
      case BOOL:
        n20 = jj_consume_token(BOOL);
                      n19 = JTBToolkit.makeNodeToken(n20);
           n0 = new NodeChoice(n19, 9);
        break;
      case COMPLEX:
        n22 = jj_consume_token(COMPLEX);
                         n21 = JTBToolkit.makeNodeToken(n22);
           n0 = new NodeChoice(n21, 10);
        break;
      case ATOMIC:
        n23 = AtomicSpecifier();
           n0 = new NodeChoice(n23, 11);
        break;
      case STRUCT:
      case UNION:
        n24 = StructOrUnionSpecifier();
           n0 = new NodeChoice(n24, 12);
        break;
      case ENUM:
        n25 = EnumSpecifier();
           n0 = new NodeChoice(n25, 13);
        break;
      default:
        jj_la1[40] = jj_gen;
        if (isType(getToken(1).image)) {
          n26 = TypedefName();
           n0 = new NodeChoice(n26, 14);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
     {if (true) return new TypeSpecifier(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("TypeSpecifier");
    }
  }

  final public StructOrUnionSpecifier StructOrUnionSpecifier() throws ParseException {
    trace_call("StructOrUnionSpecifier");
    try {
   StructOrUnion n0;
   NodeChoice n1;
   NodeSequence n2;
   NodeOptional n3 = new NodeOptional();
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   StructDeclarationList n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
      typedefParsingStack.push(false);
      n0 = StructOrUnion();
      if (jj_2_15(2)) {
           n2 = new NodeSequence(5);
        switch (jj_nt.kind) {
        case IDENTIFIER:
          n5 = jj_consume_token(IDENTIFIER);
                              n4 = JTBToolkit.makeNodeToken(n5);
              n3.addNode(n4);
          break;
        default:
          jj_la1[41] = jj_gen;
          ;
        }
           n2.addNode(n3);
        n7 = jj_consume_token(CBL);
                  n6 = JTBToolkit.makeNodeToken(n7);
           n2.addNode(n6);
        n8 = StructDeclarationList();
           n2.addNode(n8);
        n10 = jj_consume_token(CBR);
                   n9 = JTBToolkit.makeNodeToken(n10);
           n2.addNode(n9);
           n1 = new NodeChoice(n2, 0);
      } else {
        switch (jj_nt.kind) {
        case IDENTIFIER:
          n12 = jj_consume_token(IDENTIFIER);
                            n11 = JTBToolkit.makeNodeToken(n12);
           n1 = new NodeChoice(n11, 1);
          break;
        default:
          jj_la1[42] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      typedefParsingStack.pop();
     {if (true) return new StructOrUnionSpecifier(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("StructOrUnionSpecifier");
    }
  }

  final public StructOrUnion StructOrUnion() throws ParseException {
    trace_call("StructOrUnion");
    try {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
      switch (jj_nt.kind) {
      case STRUCT:
        n2 = jj_consume_token(STRUCT);
                       n1 = JTBToolkit.makeNodeToken(n2);
           n0 = new NodeChoice(n1, 0);
        break;
      case UNION:
        n4 = jj_consume_token(UNION);
                      n3 = JTBToolkit.makeNodeToken(n4);
           n0 = new NodeChoice(n3, 1);
        break;
      default:
        jj_la1[43] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     {if (true) return new StructOrUnion(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("StructOrUnion");
    }
  }

  final public StructDeclarationList StructDeclarationList() throws ParseException {
    trace_call("StructDeclarationList");
    try {
   NodeList n0 = new NodeList();
   StructDeclaration n1;
      label_7:
      while (true) {
        n1 = StructDeclaration();
        n0.addNode(n1);
        if (jj_2_16(1)) {
          ;
        } else {
          break label_7;
        }
      }
     n0.nodes.trimToSize();
     {if (true) return new StructDeclarationList(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("StructDeclarationList");
    }
  }

  final public StructDeclaration StructDeclaration() throws ParseException {
    trace_call("StructDeclaration");
    try {
   NodeChoice n0;
   NodeSequence n1;
   SpecifierQualifierList n2;
   NodeOptional n3 = new NodeOptional();
   StructDeclaratorList n4;
   NodeToken n5;
   Token n6;
   Static_AssertDeclaration n7;
      if (jj_2_17(1)) {
           n1 = new NodeSequence(3);
        n2 = SpecifierQualifierList();
           n1.addNode(n2);
        switch (jj_nt.kind) {
        case IDENTIFIER:
        case RBL:
        case STAR:
        case COLON:
          n4 = StructDeclaratorList();
              n3.addNode(n4);
          break;
        default:
          jj_la1[44] = jj_gen;
          ;
        }
           n1.addNode(n3);
        n6 = jj_consume_token(SEMICOLON);
                  n5 = JTBToolkit.makeNodeToken(n6);
           n1.addNode(n5);
           n0 = new NodeChoice(n1, 0);
      } else {
        switch (jj_nt.kind) {
        case STATICASSERT:
          n7 = Static_AssertDeclaration();
           n0 = new NodeChoice(n7, 1);
          break;
        default:
          jj_la1[45] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
     {if (true) return new StructDeclaration(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("StructDeclaration");
    }
  }

  final public SpecifierQualifierList SpecifierQualifierList() throws ParseException {
    trace_call("SpecifierQualifierList");
    try {
   NodeChoice n0;
   NodeSequence n1;
   TypeSpecifier n2;
   NodeOptional n3 = new NodeOptional();
   SpecifierQualifierList n4;
   NodeSequence n5;
   TypeQualifier n6;
   NodeOptional n7 = new NodeOptional();
   SpecifierQualifierList n8;
      if (jj_2_20(2)) {
        n1 = new NodeSequence(3);
        n2 = TypeSpecifier();
        n1.addNode(n2);
        if (jj_2_18(2147483647)) {
          n4 = SpecifierQualifierList();
           n3.addNode(n4);
        } else {
          ;
        }
        n1.addNode(n3);
        n0 = new NodeChoice(n1, 0);
      } else {
        switch (jj_nt.kind) {
        case CONST:
        case RESTRICT:
        case VOLATILE:
        case ATOMIC:
        n5 = new NodeSequence(2);
          n6 = TypeQualifier();
        n5.addNode(n6);
          if (jj_2_19(2147483647)) {
            n8 = SpecifierQualifierList();
           n7.addNode(n8);
          } else {
            ;
          }
        n5.addNode(n7);
        n0 = new NodeChoice(n5, 1);
          break;
        default:
          jj_la1[46] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
     {if (true) return new SpecifierQualifierList(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SpecifierQualifierList");
    }
  }

  final public StructDeclaratorList StructDeclaratorList() throws ParseException {
    trace_call("StructDeclaratorList");
    try {
   StructDeclarator n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   StructDeclarator n5;
      n0 = StructDeclarator();
      label_8:
      while (true) {
        switch (jj_nt.kind) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[47] = jj_gen;
          break label_8;
        }
        n2 = new NodeSequence(2);
        n4 = jj_consume_token(COMMA);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
        n5 = StructDeclarator();
        n2.addNode(n5);
        n1.addNode(n2);
      }
     n1.nodes.trimToSize();
     {if (true) return new StructDeclaratorList(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("StructDeclaratorList");
    }
  }

  final public StructDeclarator StructDeclarator() throws ParseException {
    trace_call("StructDeclarator");
    try {
   NodeChoice n0;
   NodeSequence n1;
   Declarator n2;
   NodeOptional n3 = new NodeOptional();
   NodeSequence n4;
   NodeToken n5;
   Token n6;
   ConstantExpression n7;
   NodeSequence n8;
   NodeToken n9;
   Token n10;
   ConstantExpression n11;
      switch (jj_nt.kind) {
      case IDENTIFIER:
      case RBL:
      case STAR:
        n1 = new NodeSequence(2);
        n2 = Declarator();
        n1.addNode(n2);
        switch (jj_nt.kind) {
        case COLON:
           n4 = new NodeSequence(2);
          n6 = jj_consume_token(COLON);
                  n5 = JTBToolkit.makeNodeToken(n6);
           n4.addNode(n5);
          n7 = ConstantExpression();
           n4.addNode(n7);
           n3.addNode(n4);
          break;
        default:
          jj_la1[48] = jj_gen;
          ;
        }
        n1.addNode(n3);
        n0 = new NodeChoice(n1, 0);
        break;
      case COLON:
        n8 = new NodeSequence(2);
        n10 = jj_consume_token(COLON);
                n9 = JTBToolkit.makeNodeToken(n10);
        n8.addNode(n9);
        n11 = ConstantExpression();
        n8.addNode(n11);
        n0 = new NodeChoice(n8, 1);
        break;
      default:
        jj_la1[49] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     {if (true) return new StructDeclarator(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("StructDeclarator");
    }
  }

  final public EnumSpecifier EnumSpecifier() throws ParseException {
    trace_call("EnumSpecifier");
    try {
   NodeToken n0;
   Token n1;
   NodeChoice n2;
   NodeSequence n3;
   NodeOptional n4 = new NodeOptional();
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   EnumeratorList n9;
   NodeOptional n10 = new NodeOptional();
   NodeToken n11;
   Token n12;
   NodeToken n13;
   Token n14;
   NodeToken n15;
   Token n16;
      n1 = jj_consume_token(ENUM);
               n0 = JTBToolkit.makeNodeToken(n1);
      if (jj_2_21(3)) {
           n3 = new NodeSequence(6);
        switch (jj_nt.kind) {
        case IDENTIFIER:
          n6 = jj_consume_token(IDENTIFIER);
                              n5 = JTBToolkit.makeNodeToken(n6);
              n4.addNode(n5);
          break;
        default:
          jj_la1[50] = jj_gen;
          ;
        }
           n3.addNode(n4);
        n8 = jj_consume_token(CBL);
                  n7 = JTBToolkit.makeNodeToken(n8);
           n3.addNode(n7);
        n9 = EnumeratorList();
           n3.addNode(n9);
        switch (jj_nt.kind) {
        case COMMA:
          n12 = jj_consume_token(COMMA);
                      n11 = JTBToolkit.makeNodeToken(n12);
              n10.addNode(n11);
          break;
        default:
          jj_la1[51] = jj_gen;
          ;
        }
           n3.addNode(n10);
        n14 = jj_consume_token(CBR);
                   n13 = JTBToolkit.makeNodeToken(n14);
           n3.addNode(n13);
           n2 = new NodeChoice(n3, 0);
      } else {
        switch (jj_nt.kind) {
        case IDENTIFIER:
          n16 = jj_consume_token(IDENTIFIER);
                            n15 = JTBToolkit.makeNodeToken(n16);
           n2 = new NodeChoice(n15, 1);
          break;
        default:
          jj_la1[52] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
     {if (true) return new EnumSpecifier(n0,n2);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("EnumSpecifier");
    }
  }

  final public EnumeratorList EnumeratorList() throws ParseException {
    trace_call("EnumeratorList");
    try {
   Enumerator n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   Enumerator n5;
      n0 = Enumerator();
      label_9:
      while (true) {
        if (jj_2_22(2)) {
          ;
        } else {
          break label_9;
        }
        n2 = new NodeSequence(2);
        n4 = jj_consume_token(COMMA);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
        n5 = Enumerator();
        n2.addNode(n5);
        n1.addNode(n2);
      }
     n1.nodes.trimToSize();
     {if (true) return new EnumeratorList(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("EnumeratorList");
    }
  }

  final public Enumerator Enumerator() throws ParseException {
    trace_call("Enumerator");
    try {
   EnumerationConstant n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   ConstantExpression n5;
      n0 = EnumerationConstant();
      switch (jj_nt.kind) {
      case ASSIGNMENT:
        n2 = new NodeSequence(2);
        n4 = jj_consume_token(ASSIGNMENT);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
        n5 = ConstantExpression();
        n2.addNode(n5);
        n1.addNode(n2);
        break;
      default:
        jj_la1[53] = jj_gen;
        ;
      }
     {if (true) return new Enumerator(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Enumerator");
    }
  }

  final public AtomicSpecifier AtomicSpecifier() throws ParseException {
    trace_call("AtomicSpecifier");
    try {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   TypedefName n4;
   NodeToken n5;
   Token n6;
      n1 = jj_consume_token(ATOMIC);
                 n0 = JTBToolkit.makeNodeToken(n1);
      n3 = jj_consume_token(RBL);
            n2 = JTBToolkit.makeNodeToken(n3);
      if (isType(getToken(1).image)) {

      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
      n4 = TypedefName();
      n6 = jj_consume_token(RBR);
            n5 = JTBToolkit.makeNodeToken(n6);
     {if (true) return new AtomicSpecifier(n0,n2,n4,n5);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("AtomicSpecifier");
    }
  }

  final public TypeQualifier TypeQualifier() throws ParseException {
    trace_call("TypeQualifier");
    try {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
      switch (jj_nt.kind) {
      case CONST:
        n2 = jj_consume_token(CONST);
                      n1 = JTBToolkit.makeNodeToken(n2);
           n0 = new NodeChoice(n1, 0);
        break;
      case RESTRICT:
        n4 = jj_consume_token(RESTRICT);
                         n3 = JTBToolkit.makeNodeToken(n4);
           n0 = new NodeChoice(n3, 1);
        break;
      case VOLATILE:
        n6 = jj_consume_token(VOLATILE);
                         n5 = JTBToolkit.makeNodeToken(n6);
           n0 = new NodeChoice(n5, 2);
        break;
      case ATOMIC:
        n8 = jj_consume_token(ATOMIC);
                       n7 = JTBToolkit.makeNodeToken(n8);
           n0 = new NodeChoice(n7, 3);
        break;
      default:
        jj_la1[54] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     {if (true) return new TypeQualifier(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("TypeQualifier");
    }
  }

  final public FunctionSpecifier FunctionSpecifier() throws ParseException {
    trace_call("FunctionSpecifier");
    try {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeToken n3;
   Token n4;
      switch (jj_nt.kind) {
      case INLINE:
        n2 = jj_consume_token(INLINE);
                       n1 = JTBToolkit.makeNodeToken(n2);
           n0 = new NodeChoice(n1, 0);
        break;
      case NORETURN:
        n4 = jj_consume_token(NORETURN);
                         n3 = JTBToolkit.makeNodeToken(n4);
           n0 = new NodeChoice(n3, 1);
        break;
      default:
        jj_la1[55] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     {if (true) return new FunctionSpecifier(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("FunctionSpecifier");
    }
  }

  final public AlignmentSpecifier AlignmentSpecifier() throws ParseException {
    trace_call("AlignmentSpecifier");
    try {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeChoice n4;
   TypedefName n5;
   ConstantExpression n6;
   NodeToken n7;
   Token n8;
      n1 = jj_consume_token(ALIGNAS);
                  n0 = JTBToolkit.makeNodeToken(n1);
      n3 = jj_consume_token(RBL);
            n2 = JTBToolkit.makeNodeToken(n3);
      if (isType(getToken(1).image)) {
        n5 = TypedefName();
           n4 = new NodeChoice(n5, 0);
      } else {
        switch (jj_nt.kind) {
        case NUMBER:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case ALIGNOF:
        case SIZEOF:
        case GENERIC:
        case IDENTIFIER:
        case INC:
        case DEC:
        case RBL:
        case STAR:
        case PLUS:
        case MINUS:
        case EXCL:
        case AMP:
        case TILDE:
          n6 = ConstantExpression();
           n4 = new NodeChoice(n6, 1);
          break;
        default:
          jj_la1[56] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      n8 = jj_consume_token(RBR);
            n7 = JTBToolkit.makeNodeToken(n8);
     {if (true) return new AlignmentSpecifier(n0,n2,n4,n7);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("AlignmentSpecifier");
    }
  }

  final public Declarator Declarator() throws ParseException {
    trace_call("Declarator");
    try {
   NodeOptional n0 = new NodeOptional();
   Pointer n1;
   DirectDeclarator n2;
      switch (jj_nt.kind) {
      case STAR:
        n1 = Pointer();
        n0.addNode(n1);
        break;
      default:
        jj_la1[57] = jj_gen;
        ;
      }
      n2 = DirectDeclarator();
     {if (true) return new Declarator(n0,n2);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Declarator");
    }
  }

  final public DirectDeclarator DirectDeclarator() throws ParseException {
    trace_call("DirectDeclarator");
    try {
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   NodeSequence n3;
   NodeToken n4;
   Token n5;
   Declarator n6;
   NodeToken n7;
   Token n8;
   NodeListOptional n9 = new NodeListOptional();
   NodeChoice n10;
   NodeSequence n11;
   NodeToken n12;
   Token n13;
   NodeChoice n14;
   NodeSequence n15;
   NodeToken n16;
   Token n17;
   NodeOptional n18;
   TypeQualifierList n19;
   AssignmentExpression n20;
   NodeSequence n21;
   TypeQualifierList n22;
   NodeToken n23;
   Token n24;
   AssignmentExpression n25;
   NodeSequence n26;
   NodeOptional n27;
   TypeQualifierList n28;
   NodeToken n29;
   Token n30;
   NodeToken n31;
   Token n32;
   NodeOptional n33;
   ConstantExpression n34;
   NodeToken n35;
   Token n36;
   NodeSequence n37;
   NodeToken n38;
   Token n39;
   ParameterTypeList n40;
   NodeToken n41;
   Token n42;
   NodeSequence n43;
   NodeToken n44;
   Token n45;
   NodeOptional n46;
   IdentifierList n47;
   NodeToken n48;
   Token n49;

   Token t;
      switch (jj_nt.kind) {
      case IDENTIFIER:
        t = n2 = jj_consume_token(IDENTIFIER);
                          n1 = JTBToolkit.makeNodeToken(n2);
            if ( !(typedefParsingStack.empty()) && (typedefParsingStack.peek()) )
            {
               addType(t.image);
            }
           n0 = new NodeChoice(n1, 0);
        break;
      case RBL:
           n3 = new NodeSequence(3);
        n5 = jj_consume_token(RBL);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n3.addNode(n4);
        n6 = Declarator();
           n3.addNode(n6);
        n8 = jj_consume_token(RBR);
                  n7 = JTBToolkit.makeNodeToken(n8);
           n3.addNode(n7);
           n0 = new NodeChoice(n3, 1);
        break;
      default:
        jj_la1[58] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      typedefParsingStack.push(false);
      label_10:
      while (true) {
        switch (jj_nt.kind) {
        case RBL:
        case SBL:
          ;
          break;
        default:
          jj_la1[59] = jj_gen;
          break label_10;
        }
        n18 = new NodeOptional();
        n27 = new NodeOptional();
        n33 = new NodeOptional();
        n46 = new NodeOptional();
        switch (jj_nt.kind) {
        case SBL:
           n11 = new NodeSequence(3);
          n13 = jj_consume_token(SBL);
                   n12 = JTBToolkit.makeNodeToken(n13);
           n11.addNode(n12);
          switch (jj_nt.kind) {
          case STATIC:
                 n15 = new NodeSequence(3);
            n17 = jj_consume_token(STATIC);
                              n16 = JTBToolkit.makeNodeToken(n17);
                 n15.addNode(n16);
            switch (jj_nt.kind) {
            case CONST:
            case RESTRICT:
            case VOLATILE:
            case ATOMIC:
              n19 = TypeQualifierList();
                    n18.addNode(n19);
              break;
            default:
              jj_la1[60] = jj_gen;
              ;
            }
                 n15.addNode(n18);
            n20 = AssignmentExpression();
                 n15.addNode(n20);
                 n14 = new NodeChoice(n15, 0);
            break;
          default:
            jj_la1[63] = jj_gen;
            if (jj_2_23(2147483647)) {
                 n21 = new NodeSequence(4);
              n22 = TypeQualifierList();
                 n21.addNode(n22);
              n24 = jj_consume_token(STATIC);
                              n23 = JTBToolkit.makeNodeToken(n24);
                 n21.addNode(n23);
              n25 = AssignmentExpression();
                 n21.addNode(n25);
                 n14 = new NodeChoice(n21, 1);
            } else if (jj_2_24(2)) {
                 n26 = new NodeSequence(4);
              switch (jj_nt.kind) {
              case CONST:
              case RESTRICT:
              case VOLATILE:
              case ATOMIC:
                n28 = TypeQualifierList();
                    n27.addNode(n28);
                break;
              default:
                jj_la1[61] = jj_gen;
                ;
              }
                 n26.addNode(n27);
              n30 = jj_consume_token(STAR);
                         n29 = JTBToolkit.makeNodeToken(n30);
                 n26.addNode(n29);
              n32 = jj_consume_token(SBR);
                         n31 = JTBToolkit.makeNodeToken(n32);
                 n26.addNode(n31);
                 n14 = new NodeChoice(n26, 2);
            } else {
              switch (jj_nt.kind) {
              case NUMBER:
              case CHARACTER_LITERAL:
              case STRING_LITERAL:
              case ALIGNOF:
              case SIZEOF:
              case GENERIC:
              case IDENTIFIER:
              case INC:
              case DEC:
              case RBL:
              case STAR:
              case PLUS:
              case MINUS:
              case EXCL:
              case AMP:
              case TILDE:
                n34 = ConstantExpression();
                    n33.addNode(n34);
                break;
              default:
                jj_la1[62] = jj_gen;
                ;
              }
                 n14 = new NodeChoice(n33, 3);
            }
          }
           n11.addNode(n14);
          n36 = jj_consume_token(SBR);
                   n35 = JTBToolkit.makeNodeToken(n36);
           n11.addNode(n35);
           n10 = new NodeChoice(n11, 0);
          break;
        default:
          jj_la1[65] = jj_gen;
          if (jj_2_25(3)) {
           n37 = new NodeSequence(4);
            n39 = jj_consume_token(RBL);
                   n38 = JTBToolkit.makeNodeToken(n39);
           n37.addNode(n38);
            n40 = ParameterTypeList();
           n37.addNode(n40);
            n42 = jj_consume_token(RBR);
                   n41 = JTBToolkit.makeNodeToken(n42);
           n37.addNode(n41);
           n10 = new NodeChoice(n37, 1);
          } else {
            switch (jj_nt.kind) {
            case RBL:
           n43 = new NodeSequence(3);
              n45 = jj_consume_token(RBL);
                   n44 = JTBToolkit.makeNodeToken(n45);
           n43.addNode(n44);
              switch (jj_nt.kind) {
              case IDENTIFIER:
                n47 = IdentifierList();
              n46.addNode(n47);
                break;
              default:
                jj_la1[64] = jj_gen;
                ;
              }
           n43.addNode(n46);
              n49 = jj_consume_token(RBR);
                   n48 = JTBToolkit.makeNodeToken(n49);
           n43.addNode(n48);
           n10 = new NodeChoice(n43, 2);
              break;
            default:
              jj_la1[66] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
        n9.addNode(n10);
      }
     n9.nodes.trimToSize();
      typedefParsingStack.pop();
     {if (true) return new DirectDeclarator(n0,n9);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("DirectDeclarator");
    }
  }

  final public Pointer Pointer() throws ParseException {
    trace_call("Pointer");
    try {
   NodeToken n0;
   Token n1;
   NodeOptional n2 = new NodeOptional();
   TypeQualifierList n3;
   NodeOptional n4 = new NodeOptional();
   Pointer n5;
      n1 = jj_consume_token(STAR);
            n0 = JTBToolkit.makeNodeToken(n1);
      switch (jj_nt.kind) {
      case CONST:
      case RESTRICT:
      case VOLATILE:
      case ATOMIC:
        n3 = TypeQualifierList();
        n2.addNode(n3);
        break;
      default:
        jj_la1[67] = jj_gen;
        ;
      }
      switch (jj_nt.kind) {
      case STAR:
        n5 = Pointer();
        n4.addNode(n5);
        break;
      default:
        jj_la1[68] = jj_gen;
        ;
      }
     {if (true) return new Pointer(n0,n2,n4);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Pointer");
    }
  }

  final public TypeQualifierList TypeQualifierList() throws ParseException {
    trace_call("TypeQualifierList");
    try {
   NodeList n0 = new NodeList();
   TypeQualifier n1;
      label_11:
      while (true) {
        n1 = TypeQualifier();
        n0.addNode(n1);
        switch (jj_nt.kind) {
        case CONST:
        case RESTRICT:
        case VOLATILE:
        case ATOMIC:
          ;
          break;
        default:
          jj_la1[69] = jj_gen;
          break label_11;
        }
      }
     n0.nodes.trimToSize();
     {if (true) return new TypeQualifierList(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("TypeQualifierList");
    }
  }

  final public ParameterTypeList ParameterTypeList() throws ParseException {
    trace_call("ParameterTypeList");
    try {
   ParameterList n0;
   NodeOptional n1 = new NodeOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
      n0 = ParameterList();
      switch (jj_nt.kind) {
      case COMMA:
        n2 = new NodeSequence(2);
        n4 = jj_consume_token(COMMA);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
        n6 = jj_consume_token(ELLIPSIS);
                            n5 = JTBToolkit.makeNodeToken(n6);
        n2.addNode(n5);
        n1.addNode(n2);
        break;
      default:
        jj_la1[70] = jj_gen;
        ;
      }
     {if (true) return new ParameterTypeList(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ParameterTypeList");
    }
  }

  final public ParameterList ParameterList() throws ParseException {
    trace_call("ParameterList");
    try {
   ParameterDeclaration n0;
   NodeListOptional n1 = new NodeListOptional();
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   ParameterDeclaration n5;
      n0 = ParameterDeclaration();
      label_12:
      while (true) {
        if (jj_2_26(2)) {
          ;
        } else {
          break label_12;
        }
        n2 = new NodeSequence(2);
        n4 = jj_consume_token(COMMA);
               n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
        n5 = ParameterDeclaration();
        n2.addNode(n5);
        n1.addNode(n2);
      }
     n1.nodes.trimToSize();
     {if (true) return new ParameterList(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ParameterList");
    }
  }

  final public ParameterDeclaration ParameterDeclaration() throws ParseException {
    trace_call("ParameterDeclaration");
    try {
   DeclarationSpecifiers n0;
   NodeChoice n1;
   Declarator n2;
   NodeOptional n3 = new NodeOptional();
   AbstractDeclarator n4;
      n0 = DeclarationSpecifiers();
      if (jj_2_27(2147483647)) {
        n2 = Declarator();
           n1 = new NodeChoice(n2, 0);
      } else {
        switch (jj_nt.kind) {
        case RBL:
        case SBL:
        case STAR:
          n4 = AbstractDeclarator();
              n3.addNode(n4);
          break;
        default:
          jj_la1[71] = jj_gen;
          ;
        }
           n1 = new NodeChoice(n3, 1);
      }
     {if (true) return new ParameterDeclaration(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ParameterDeclaration");
    }
  }

  final public IdentifierList IdentifierList() throws ParseException {
    trace_call("IdentifierList");
    try {
   NodeToken n0;
   Token n1;
   NodeListOptional n2 = new NodeListOptional();
   NodeSequence n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
      n1 = jj_consume_token(IDENTIFIER);
                     n0 = JTBToolkit.makeNodeToken(n1);
      label_13:
      while (true) {
        switch (jj_nt.kind) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[72] = jj_gen;
          break label_13;
        }
        n3 = new NodeSequence(2);
        n5 = jj_consume_token(COMMA);
               n4 = JTBToolkit.makeNodeToken(n5);
        n3.addNode(n4);
        n7 = jj_consume_token(IDENTIFIER);
                        n6 = JTBToolkit.makeNodeToken(n7);
        n3.addNode(n6);
        n2.addNode(n3);
      }
     n2.nodes.trimToSize();
     {if (true) return new IdentifierList(n0,n2);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("IdentifierList");
    }
  }

  final public TypeName TypeName() throws ParseException {
    trace_call("TypeName");
    try {
   SpecifierQualifierList n0;
   NodeOptional n1 = new NodeOptional();
   AbstractDeclarator n2;
      n0 = SpecifierQualifierList();
      switch (jj_nt.kind) {
      case RBL:
      case SBL:
      case STAR:
        n2 = AbstractDeclarator();
        n1.addNode(n2);
        break;
      default:
        jj_la1[73] = jj_gen;
        ;
      }
     {if (true) return new TypeName(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("TypeName");
    }
  }

  final public AbstractDeclarator AbstractDeclarator() throws ParseException {
    trace_call("AbstractDeclarator");
    try {
   NodeChoice n0;
   Pointer n1;
   NodeSequence n2;
   NodeOptional n3 = new NodeOptional();
   Pointer n4;
   DirectAbstractDeclarator n5;
      if (jj_2_28(3)) {
        n1 = Pointer();
           n0 = new NodeChoice(n1, 0);
      } else {
        switch (jj_nt.kind) {
        case RBL:
        case SBL:
        case STAR:
           n2 = new NodeSequence(2);
          switch (jj_nt.kind) {
          case STAR:
            n4 = Pointer();
              n3.addNode(n4);
            break;
          default:
            jj_la1[74] = jj_gen;
            ;
          }
           n2.addNode(n3);
          n5 = DirectAbstractDeclarator();
           n2.addNode(n5);
           n0 = new NodeChoice(n2, 1);
          break;
        default:
          jj_la1[75] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
     {if (true) return new AbstractDeclarator(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("AbstractDeclarator");
    }
  }

  final public DirectAbstractDeclarator DirectAbstractDeclarator() throws ParseException {
    trace_call("DirectAbstractDeclarator");
    try {
   NodeChoice n0;
   NodeSequence n1;
   NodeToken n2;
   Token n3;
   AbstractDeclarator n4;
   NodeToken n5;
   Token n6;
   NodeSequence n7;
   NodeToken n8;
   Token n9;
   NodeOptional n10 = new NodeOptional();
   ParameterTypeList n11;
   NodeToken n12;
   Token n13;
   NodeSequence n14;
   NodeToken n15;
   Token n16;
   NodeChoice n17;
   NodeSequence n18;
   NodeToken n19;
   Token n20;
   NodeOptional n21 = new NodeOptional();
   TypeQualifierList n22;
   AssignmentExpression n23;
   NodeSequence n24;
   TypeQualifierList n25;
   NodeToken n26;
   Token n27;
   AssignmentExpression n28;
   NodeToken n29;
   Token n30;
   NodeSequence n31;
   NodeOptional n32 = new NodeOptional();
   TypeQualifierList n33;
   AssignmentExpression n34;
   NodeToken n35;
   Token n36;
   NodeListOptional n37 = new NodeListOptional();
   NodeChoice n38;
   NodeSequence n39;
   NodeToken n40;
   Token n41;
   NodeOptional n42;
   ParameterTypeList n43;
   NodeToken n44;
   Token n45;
   NodeSequence n46;
   NodeToken n47;
   Token n48;
   NodeChoice n49;
   NodeSequence n50;
   NodeToken n51;
   Token n52;
   NodeOptional n53;
   TypeQualifierList n54;
   AssignmentExpression n55;
   NodeSequence n56;
   TypeQualifierList n57;
   NodeToken n58;
   Token n59;
   AssignmentExpression n60;
   NodeToken n61;
   Token n62;
   NodeSequence n63;
   NodeOptional n64;
   TypeQualifierList n65;
   AssignmentExpression n66;
   NodeToken n67;
   Token n68;
      if (jj_2_32(2)) {
           n1 = new NodeSequence(4);
        n3 = jj_consume_token(RBL);
                  n2 = JTBToolkit.makeNodeToken(n3);
           n1.addNode(n2);
        n4 = AbstractDeclarator();
           n1.addNode(n4);
        n6 = jj_consume_token(RBR);
                  n5 = JTBToolkit.makeNodeToken(n6);
           n1.addNode(n5);
           n0 = new NodeChoice(n1, 0);
      } else {
        switch (jj_nt.kind) {
        case RBL:
           n7 = new NodeSequence(3);
          n9 = jj_consume_token(RBL);
                  n8 = JTBToolkit.makeNodeToken(n9);
           n7.addNode(n8);
          if (jj_2_29(1)) {
            n11 = ParameterTypeList();
              n10.addNode(n11);
          } else {
            ;
          }
           n7.addNode(n10);
          n13 = jj_consume_token(RBR);
                   n12 = JTBToolkit.makeNodeToken(n13);
           n7.addNode(n12);
           n0 = new NodeChoice(n7, 1);
          break;
        case SBL:
           n14 = new NodeSequence(3);
          n16 = jj_consume_token(SBL);
                   n15 = JTBToolkit.makeNodeToken(n16);
           n14.addNode(n15);
          switch (jj_nt.kind) {
          case STATIC:
                 n18 = new NodeSequence(3);
            n20 = jj_consume_token(STATIC);
                              n19 = JTBToolkit.makeNodeToken(n20);
                 n18.addNode(n19);
            switch (jj_nt.kind) {
            case CONST:
            case RESTRICT:
            case VOLATILE:
            case ATOMIC:
              n22 = TypeQualifierList();
                    n21.addNode(n22);
              break;
            default:
              jj_la1[76] = jj_gen;
              ;
            }
                 n18.addNode(n21);
            n23 = AssignmentExpression();
                 n18.addNode(n23);
                 n17 = new NodeChoice(n18, 0);
            break;
          default:
            jj_la1[78] = jj_gen;
            if (jj_2_30(2147483647)) {
                 n24 = new NodeSequence(4);
              n25 = TypeQualifierList();
                 n24.addNode(n25);
              n27 = jj_consume_token(STATIC);
                              n26 = JTBToolkit.makeNodeToken(n27);
                 n24.addNode(n26);
              n28 = AssignmentExpression();
                 n24.addNode(n28);
                 n17 = new NodeChoice(n24, 1);
            } else if (jj_2_31(2)) {
              n30 = jj_consume_token(STAR);
                         n29 = JTBToolkit.makeNodeToken(n30);
                 n17 = new NodeChoice(n29, 2);
            } else {
              switch (jj_nt.kind) {
              case NUMBER:
              case CHARACTER_LITERAL:
              case STRING_LITERAL:
              case ALIGNOF:
              case CONST:
              case RESTRICT:
              case SIZEOF:
              case VOLATILE:
              case ATOMIC:
              case GENERIC:
              case IDENTIFIER:
              case INC:
              case DEC:
              case RBL:
              case STAR:
              case PLUS:
              case MINUS:
              case EXCL:
              case AMP:
              case TILDE:
                 n31 = new NodeSequence(2);
                switch (jj_nt.kind) {
                case CONST:
                case RESTRICT:
                case VOLATILE:
                case ATOMIC:
                  n33 = TypeQualifierList();
                    n32.addNode(n33);
                  break;
                default:
                  jj_la1[77] = jj_gen;
                  ;
                }
                 n31.addNode(n32);
                n34 = AssignmentExpression();
                 n31.addNode(n34);
                 n17 = new NodeChoice(n31, 3);
                break;
              default:
                jj_la1[79] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
            }
          }
           n14.addNode(n17);
          n36 = jj_consume_token(SBR);
                   n35 = JTBToolkit.makeNodeToken(n36);
           n14.addNode(n35);
           n0 = new NodeChoice(n14, 2);
          break;
        default:
          jj_la1[80] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      label_14:
      while (true) {
        switch (jj_nt.kind) {
        case RBL:
        case SBL:
          ;
          break;
        default:
          jj_la1[81] = jj_gen;
          break label_14;
        }
        n42 = new NodeOptional();
        n53 = new NodeOptional();
        n64 = new NodeOptional();
        switch (jj_nt.kind) {
        case RBL:
           n39 = new NodeSequence(3);
          n41 = jj_consume_token(RBL);
                   n40 = JTBToolkit.makeNodeToken(n41);
           n39.addNode(n40);
          if (jj_2_33(1)) {
            n43 = ParameterTypeList();
              n42.addNode(n43);
          } else {
            ;
          }
           n39.addNode(n42);
          n45 = jj_consume_token(RBR);
                   n44 = JTBToolkit.makeNodeToken(n45);
           n39.addNode(n44);
           n38 = new NodeChoice(n39, 0);
          break;
        case SBL:
           n46 = new NodeSequence(3);
          n48 = jj_consume_token(SBL);
                   n47 = JTBToolkit.makeNodeToken(n48);
           n46.addNode(n47);
          switch (jj_nt.kind) {
          case STATIC:
                 n50 = new NodeSequence(3);
            n52 = jj_consume_token(STATIC);
                              n51 = JTBToolkit.makeNodeToken(n52);
                 n50.addNode(n51);
            switch (jj_nt.kind) {
            case CONST:
            case RESTRICT:
            case VOLATILE:
            case ATOMIC:
              n54 = TypeQualifierList();
                    n53.addNode(n54);
              break;
            default:
              jj_la1[82] = jj_gen;
              ;
            }
                 n50.addNode(n53);
            n55 = AssignmentExpression();
                 n50.addNode(n55);
                 n49 = new NodeChoice(n50, 0);
            break;
          default:
            jj_la1[84] = jj_gen;
            if (jj_2_34(2147483647)) {
                 n56 = new NodeSequence(4);
              n57 = TypeQualifierList();
                 n56.addNode(n57);
              n59 = jj_consume_token(STATIC);
                              n58 = JTBToolkit.makeNodeToken(n59);
                 n56.addNode(n58);
              n60 = AssignmentExpression();
                 n56.addNode(n60);
                 n49 = new NodeChoice(n56, 1);
            } else if (jj_2_35(2)) {
              n62 = jj_consume_token(STAR);
                         n61 = JTBToolkit.makeNodeToken(n62);
                 n49 = new NodeChoice(n61, 2);
            } else {
              switch (jj_nt.kind) {
              case NUMBER:
              case CHARACTER_LITERAL:
              case STRING_LITERAL:
              case ALIGNOF:
              case CONST:
              case RESTRICT:
              case SIZEOF:
              case VOLATILE:
              case ATOMIC:
              case GENERIC:
              case IDENTIFIER:
              case INC:
              case DEC:
              case RBL:
              case STAR:
              case PLUS:
              case MINUS:
              case EXCL:
              case AMP:
              case TILDE:
                 n63 = new NodeSequence(2);
                switch (jj_nt.kind) {
                case CONST:
                case RESTRICT:
                case VOLATILE:
                case ATOMIC:
                  n65 = TypeQualifierList();
                    n64.addNode(n65);
                  break;
                default:
                  jj_la1[83] = jj_gen;
                  ;
                }
                 n63.addNode(n64);
                n66 = AssignmentExpression();
                 n63.addNode(n66);
                 n49 = new NodeChoice(n63, 3);
                break;
              default:
                jj_la1[85] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
            }
          }
           n46.addNode(n49);
          n68 = jj_consume_token(SBR);
                   n67 = JTBToolkit.makeNodeToken(n68);
           n46.addNode(n67);
           n38 = new NodeChoice(n46, 1);
          break;
        default:
          jj_la1[86] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        n37.addNode(n38);
      }
     n37.nodes.trimToSize();
     {if (true) return new DirectAbstractDeclarator(n0,n37);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("DirectAbstractDeclarator");
    }
  }

  final public TypedefName TypedefName() throws ParseException {
    trace_call("TypedefName");
    try {
   NodeToken n0;
   Token n1;
      n1 = jj_consume_token(IDENTIFIER);
                     n0 = JTBToolkit.makeNodeToken(n1);
     {if (true) return new TypedefName(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("TypedefName");
    }
  }

  final public Initializer Initializer() throws ParseException {
    trace_call("Initializer");
    try {
   NodeChoice n0;
   AssignmentExpression n1;
   NodeSequence n2;
   NodeToken n3;
   Token n4;
   InitializerList n5;
   NodeOptional n6 = new NodeOptional();
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
      switch (jj_nt.kind) {
      case NUMBER:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case ALIGNOF:
      case SIZEOF:
      case GENERIC:
      case IDENTIFIER:
      case INC:
      case DEC:
      case RBL:
      case STAR:
      case PLUS:
      case MINUS:
      case EXCL:
      case AMP:
      case TILDE:
        n1 = AssignmentExpression();
           n0 = new NodeChoice(n1, 0);
        break;
      case CBL:
           n2 = new NodeSequence(4);
        n4 = jj_consume_token(CBL);
                  n3 = JTBToolkit.makeNodeToken(n4);
           n2.addNode(n3);
        n5 = InitializerList();
           n2.addNode(n5);
        switch (jj_nt.kind) {
        case COMMA:
          n8 = jj_consume_token(COMMA);
                     n7 = JTBToolkit.makeNodeToken(n8);
              n6.addNode(n7);
          break;
        default:
          jj_la1[87] = jj_gen;
          ;
        }
           n2.addNode(n6);
        n10 = jj_consume_token(CBR);
                   n9 = JTBToolkit.makeNodeToken(n10);
           n2.addNode(n9);
           n0 = new NodeChoice(n2, 1);
        break;
      default:
        jj_la1[88] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     {if (true) return new Initializer(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Initializer");
    }
  }

  final public InitializerList InitializerList() throws ParseException {
    trace_call("InitializerList");
    try {
   NodeOptional n0 = new NodeOptional();
   Designation n1;
   Initializer n2;
   NodeListOptional n3 = new NodeListOptional();
   NodeSequence n4;
   NodeToken n5;
   Token n6;
   Initializer n7;
      switch (jj_nt.kind) {
      case SBL:
      case DOT:
        n1 = Designation();
        n0.addNode(n1);
        break;
      default:
        jj_la1[89] = jj_gen;
        ;
      }
      n2 = Initializer();
      label_15:
      while (true) {
        if (jj_2_36(2)) {
          ;
        } else {
          break label_15;
        }
        n4 = new NodeSequence(2);
        n6 = jj_consume_token(COMMA);
               n5 = JTBToolkit.makeNodeToken(n6);
        n4.addNode(n5);
        n7 = Initializer();
        n4.addNode(n7);
        n3.addNode(n4);
      }
     n3.nodes.trimToSize();
     {if (true) return new InitializerList(n0,n2,n3);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("InitializerList");
    }
  }

  final public Designation Designation() throws ParseException {
    trace_call("Designation");
    try {
   DesignatorList n0;
   NodeToken n1;
   Token n2;
      n0 = DesignatorList();
      n2 = jj_consume_token(ASSIGNMENT);
            n1 = JTBToolkit.makeNodeToken(n2);
     {if (true) return new Designation(n0,n1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Designation");
    }
  }

  final public DesignatorList DesignatorList() throws ParseException {
    trace_call("DesignatorList");
    try {
   NodeList n0 = new NodeList();
   Designator n1;
      label_16:
      while (true) {
        n1 = Designator();
        n0.addNode(n1);
        switch (jj_nt.kind) {
        case SBL:
        case DOT:
          ;
          break;
        default:
          jj_la1[90] = jj_gen;
          break label_16;
        }
      }
     n0.nodes.trimToSize();
     {if (true) return new DesignatorList(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("DesignatorList");
    }
  }

  final public Designator Designator() throws ParseException {
    trace_call("Designator");
    try {
   NodeChoice n0;
   NodeSequence n1;
   NodeToken n2;
   Token n3;
   ConstantExpression n4;
   NodeToken n5;
   Token n6;
   NodeSequence n7;
   NodeToken n8;
   Token n9;
   NodeToken n10;
   Token n11;
      switch (jj_nt.kind) {
      case SBL:
           n1 = new NodeSequence(3);
        n3 = jj_consume_token(SBL);
                  n2 = JTBToolkit.makeNodeToken(n3);
           n1.addNode(n2);
        n4 = ConstantExpression();
           n1.addNode(n4);
        n6 = jj_consume_token(SBR);
                  n5 = JTBToolkit.makeNodeToken(n6);
           n1.addNode(n5);
           n0 = new NodeChoice(n1, 0);
        break;
      case DOT:
           n7 = new NodeSequence(2);
        n9 = jj_consume_token(DOT);
                  n8 = JTBToolkit.makeNodeToken(n9);
           n7.addNode(n8);
        n11 = jj_consume_token(IDENTIFIER);
                            n10 = JTBToolkit.makeNodeToken(n11);
           n7.addNode(n10);
           n0 = new NodeChoice(n7, 1);
        break;
      default:
        jj_la1[91] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     {if (true) return new Designator(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Designator");
    }
  }

  final public Static_AssertDeclaration Static_AssertDeclaration() throws ParseException {
    trace_call("Static_AssertDeclaration");
    try {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   ConstantExpression n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
      n1 = jj_consume_token(STATICASSERT);
                       n0 = JTBToolkit.makeNodeToken(n1);
      n3 = jj_consume_token(RBL);
            n2 = JTBToolkit.makeNodeToken(n3);
      n4 = ConstantExpression();
      n6 = jj_consume_token(COMMA);
            n5 = JTBToolkit.makeNodeToken(n6);
      n8 = jj_consume_token(STRING_LITERAL);
                         n7 = JTBToolkit.makeNodeToken(n8);
      n10 = jj_consume_token(RBR);
             n9 = JTBToolkit.makeNodeToken(n10);
      n12 = jj_consume_token(SEMICOLON);
             n11 = JTBToolkit.makeNodeToken(n12);
     {if (true) return new Static_AssertDeclaration(n0,n2,n4,n5,n7,n9,n11);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Static_AssertDeclaration");
    }
  }

  final public Statement Statement() throws ParseException {
    trace_call("Statement");
    try {
   NodeChoice n0;
   LabeledStatement n1;
   CompoundStatement n2;
   ExpressionStatement n3;
   IfStatement n4;
   SwitchStatement n5;
   WhileStatement n6;
   DoStatement n7;
   ForStatement n8;
   JumpStatement n9;
      if (jj_2_37(2)) {
        n1 = LabeledStatement();
           n0 = new NodeChoice(n1, 0);
      } else {
        switch (jj_nt.kind) {
        case CBL:
          n2 = CompoundStatement();
           n0 = new NodeChoice(n2, 1);
          break;
        case NUMBER:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case ALIGNOF:
        case SIZEOF:
        case GENERIC:
        case IDENTIFIER:
        case INC:
        case DEC:
        case RBL:
        case STAR:
        case PLUS:
        case MINUS:
        case EXCL:
        case AMP:
        case TILDE:
        case SEMICOLON:
          n3 = ExpressionStatement();
           n0 = new NodeChoice(n3, 2);
          break;
        case IF:
          n4 = IfStatement();
           n0 = new NodeChoice(n4, 3);
          break;
        case SWITCH:
          n5 = SwitchStatement();
           n0 = new NodeChoice(n5, 4);
          break;
        case WHILE:
          n6 = WhileStatement();
           n0 = new NodeChoice(n6, 5);
          break;
        case DO:
          n7 = DoStatement();
           n0 = new NodeChoice(n7, 6);
          break;
        case FOR:
          n8 = ForStatement();
           n0 = new NodeChoice(n8, 7);
          break;
        case BREAK:
        case CONTINUE:
        case GOTO:
        case RETURN:
          n9 = JumpStatement();
           n0 = new NodeChoice(n9, 8);
          break;
        default:
          jj_la1[92] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
     {if (true) return new Statement(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Statement");
    }
  }

  final public LabeledStatement LabeledStatement() throws ParseException {
    trace_call("LabeledStatement");
    try {
   NodeChoice n0;
   NodeSequence n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   Statement n6;
   CaseStatement n7;
   DefaultStatement n8;
      switch (jj_nt.kind) {
      case IDENTIFIER:
           n1 = new NodeSequence(3);
        n3 = jj_consume_token(IDENTIFIER);
                           n2 = JTBToolkit.makeNodeToken(n3);
           n1.addNode(n2);
        n5 = jj_consume_token(COLON);
                  n4 = JTBToolkit.makeNodeToken(n5);
           n1.addNode(n4);
        n6 = Statement();
           n1.addNode(n6);
           n0 = new NodeChoice(n1, 0);
        break;
      case CASE:
        n7 = CaseStatement();
           n0 = new NodeChoice(n7, 1);
        break;
      case DFAULT:
        n8 = DefaultStatement();
           n0 = new NodeChoice(n8, 2);
        break;
      default:
        jj_la1[93] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     {if (true) return new LabeledStatement(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("LabeledStatement");
    }
  }

  final public CaseStatement CaseStatement() throws ParseException {
    trace_call("CaseStatement");
    try {
   NodeToken n0;
   Token n1;
   ConstantExpression n2;
   NodeToken n3;
   Token n4;
   Statement n5;
      n1 = jj_consume_token(CASE);
               n0 = JTBToolkit.makeNodeToken(n1);
      n2 = ConstantExpression();
      n4 = jj_consume_token(COLON);
            n3 = JTBToolkit.makeNodeToken(n4);
      n5 = Statement();
     {if (true) return new CaseStatement(n0,n2,n3,n5);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("CaseStatement");
    }
  }

  final public DefaultStatement DefaultStatement() throws ParseException {
    trace_call("DefaultStatement");
    try {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Statement n4;
      n1 = jj_consume_token(DFAULT);
                 n0 = JTBToolkit.makeNodeToken(n1);
      n3 = jj_consume_token(COLON);
            n2 = JTBToolkit.makeNodeToken(n3);
      n4 = Statement();
     {if (true) return new DefaultStatement(n0,n2,n4);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("DefaultStatement");
    }
  }

  final public CompoundStatement CompoundStatement() throws ParseException {
    trace_call("CompoundStatement");
    try {
   NodeToken n0;
   Token n1;
   NodeOptional n2 = new NodeOptional();
   BlockItemList n3;
   NodeToken n4;
   Token n5;
      n1 = jj_consume_token(CBL);
            n0 = JTBToolkit.makeNodeToken(n1);
      if (jj_2_38(1)) {
        n3 = BlockItemList();
        n2.addNode(n3);
      } else {
        ;
      }
      n5 = jj_consume_token(CBR);
            n4 = JTBToolkit.makeNodeToken(n5);
     {if (true) return new CompoundStatement(n0,n2,n4);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("CompoundStatement");
    }
  }

  final public BlockItemList BlockItemList() throws ParseException {
    trace_call("BlockItemList");
    try {
   NodeList n0 = new NodeList();
   BlockItem n1;
      label_17:
      while (true) {
        n1 = BlockItem();
        n0.addNode(n1);
        if (jj_2_39(1)) {
          ;
        } else {
          break label_17;
        }
      }
     n0.nodes.trimToSize();
     {if (true) return new BlockItemList(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("BlockItemList");
    }
  }

  final public BlockItem BlockItem() throws ParseException {
    trace_call("BlockItem");
    try {
   NodeChoice n0;
   Declaration n1;
   Statement n2;
      if (jj_2_40(1)) {
        n1 = Declaration();
        n0 = new NodeChoice(n1, 0);
      } else {
        switch (jj_nt.kind) {
        case NUMBER:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case ALIGNOF:
        case BREAK:
        case CASE:
        case CONTINUE:
        case DFAULT:
        case DO:
        case FOR:
        case GOTO:
        case IF:
        case RETURN:
        case SIZEOF:
        case SWITCH:
        case WHILE:
        case GENERIC:
        case IDENTIFIER:
        case INC:
        case DEC:
        case RBL:
        case CBL:
        case STAR:
        case PLUS:
        case MINUS:
        case EXCL:
        case AMP:
        case TILDE:
        case SEMICOLON:
          n2 = Statement();
        n0 = new NodeChoice(n2, 1);
          break;
        default:
          jj_la1[94] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
     {if (true) return new BlockItem(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("BlockItem");
    }
  }

  final public ExpressionStatement ExpressionStatement() throws ParseException {
    trace_call("ExpressionStatement");
    try {
   NodeOptional n0 = new NodeOptional();
   Expression n1;
   NodeToken n2;
   Token n3;
      switch (jj_nt.kind) {
      case NUMBER:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case ALIGNOF:
      case SIZEOF:
      case GENERIC:
      case IDENTIFIER:
      case INC:
      case DEC:
      case RBL:
      case STAR:
      case PLUS:
      case MINUS:
      case EXCL:
      case AMP:
      case TILDE:
        n1 = Expression();
        n0.addNode(n1);
        break;
      default:
        jj_la1[95] = jj_gen;
        ;
      }
      n3 = jj_consume_token(SEMICOLON);
            n2 = JTBToolkit.makeNodeToken(n3);
     {if (true) return new ExpressionStatement(n0,n2);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ExpressionStatement");
    }
  }

  final public IfStatement IfStatement() throws ParseException {
    trace_call("IfStatement");
    try {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
   NodeToken n5;
   Token n6;
   Statement n7;
   NodeOptional n8 = new NodeOptional();
   NodeSequence n9;
   NodeToken n10;
   Token n11;
   Statement n12;
      n1 = jj_consume_token(IF);
             n0 = JTBToolkit.makeNodeToken(n1);
      n3 = jj_consume_token(RBL);
            n2 = JTBToolkit.makeNodeToken(n3);
      n4 = Expression();
      n6 = jj_consume_token(RBR);
            n5 = JTBToolkit.makeNodeToken(n6);
      n7 = Statement();
      if (jj_2_41(2)) {
        n9 = new NodeSequence(2);
        n11 = jj_consume_token(ELSE);
                   n10 = JTBToolkit.makeNodeToken(n11);
        n9.addNode(n10);
        n12 = Statement();
        n9.addNode(n12);
        n8.addNode(n9);
      } else {
        ;
      }
     {if (true) return new IfStatement(n0,n2,n4,n5,n7,n8);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("IfStatement");
    }
  }

  final public SwitchStatement SwitchStatement() throws ParseException {
    trace_call("SwitchStatement");
    try {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
   NodeToken n5;
   Token n6;
   Statement n7;
      n1 = jj_consume_token(SWITCH);
                 n0 = JTBToolkit.makeNodeToken(n1);
      n3 = jj_consume_token(RBL);
            n2 = JTBToolkit.makeNodeToken(n3);
      n4 = Expression();
      n6 = jj_consume_token(RBR);
            n5 = JTBToolkit.makeNodeToken(n6);
      n7 = Statement();
     {if (true) return new SwitchStatement(n0,n2,n4,n5,n7);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SwitchStatement");
    }
  }

  final public WhileStatement WhileStatement() throws ParseException {
    trace_call("WhileStatement");
    try {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   Expression n4;
   NodeToken n5;
   Token n6;
   Statement n7;
      n1 = jj_consume_token(WHILE);
                n0 = JTBToolkit.makeNodeToken(n1);
      n3 = jj_consume_token(RBL);
            n2 = JTBToolkit.makeNodeToken(n3);
      n4 = Expression();
      n6 = jj_consume_token(RBR);
            n5 = JTBToolkit.makeNodeToken(n6);
      n7 = Statement();
     {if (true) return new WhileStatement(n0,n2,n4,n5,n7);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("WhileStatement");
    }
  }

  final public DoStatement DoStatement() throws ParseException {
    trace_call("DoStatement");
    try {
   NodeToken n0;
   Token n1;
   Statement n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   Expression n7;
   NodeToken n8;
   Token n9;
   NodeToken n10;
   Token n11;
      n1 = jj_consume_token(DO);
             n0 = JTBToolkit.makeNodeToken(n1);
      n2 = Statement();
      n4 = jj_consume_token(WHILE);
                n3 = JTBToolkit.makeNodeToken(n4);
      n6 = jj_consume_token(RBL);
            n5 = JTBToolkit.makeNodeToken(n6);
      n7 = Expression();
      n9 = jj_consume_token(RBR);
            n8 = JTBToolkit.makeNodeToken(n9);
      n11 = jj_consume_token(SEMICOLON);
             n10 = JTBToolkit.makeNodeToken(n11);
     {if (true) return new DoStatement(n0,n2,n3,n5,n7,n8,n10);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("DoStatement");
    }
  }

  final public ForStatement ForStatement() throws ParseException {
    trace_call("ForStatement");
    try {
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeChoice n4;
   NodeSequence n5;
   Declaration n6;
   NodeOptional n7 = new NodeOptional();
   Expression n8;
   NodeSequence n9;
   NodeOptional n10 = new NodeOptional();
   Expression n11;
   NodeToken n12;
   Token n13;
   NodeOptional n14 = new NodeOptional();
   Expression n15;
   NodeToken n16;
   Token n17;
   NodeOptional n18 = new NodeOptional();
   Expression n19;
   NodeToken n20;
   Token n21;
   Statement n22;
      n1 = jj_consume_token(FOR);
              n0 = JTBToolkit.makeNodeToken(n1);
      n3 = jj_consume_token(RBL);
            n2 = JTBToolkit.makeNodeToken(n3);
      if (jj_2_42(2147483647)) {
           n5 = new NodeSequence(3);
        n6 = Declaration();
           n5.addNode(n6);
        switch (jj_nt.kind) {
        case NUMBER:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case ALIGNOF:
        case SIZEOF:
        case GENERIC:
        case IDENTIFIER:
        case INC:
        case DEC:
        case RBL:
        case STAR:
        case PLUS:
        case MINUS:
        case EXCL:
        case AMP:
        case TILDE:
          n8 = Expression();
              n7.addNode(n8);
          break;
        default:
          jj_la1[96] = jj_gen;
          ;
        }
           n5.addNode(n7);
           n4 = new NodeChoice(n5, 0);
      } else {
        switch (jj_nt.kind) {
        case NUMBER:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case ALIGNOF:
        case SIZEOF:
        case GENERIC:
        case IDENTIFIER:
        case INC:
        case DEC:
        case RBL:
        case STAR:
        case PLUS:
        case MINUS:
        case EXCL:
        case AMP:
        case TILDE:
        case SEMICOLON:
           n9 = new NodeSequence(3);
          switch (jj_nt.kind) {
          case NUMBER:
          case CHARACTER_LITERAL:
          case STRING_LITERAL:
          case ALIGNOF:
          case SIZEOF:
          case GENERIC:
          case IDENTIFIER:
          case INC:
          case DEC:
          case RBL:
          case STAR:
          case PLUS:
          case MINUS:
          case EXCL:
          case AMP:
          case TILDE:
            n11 = Expression();
              n10.addNode(n11);
            break;
          default:
            jj_la1[97] = jj_gen;
            ;
          }
           n9.addNode(n10);
          n13 = jj_consume_token(SEMICOLON);
                   n12 = JTBToolkit.makeNodeToken(n13);
           n9.addNode(n12);
          switch (jj_nt.kind) {
          case NUMBER:
          case CHARACTER_LITERAL:
          case STRING_LITERAL:
          case ALIGNOF:
          case SIZEOF:
          case GENERIC:
          case IDENTIFIER:
          case INC:
          case DEC:
          case RBL:
          case STAR:
          case PLUS:
          case MINUS:
          case EXCL:
          case AMP:
          case TILDE:
            n15 = Expression();
              n14.addNode(n15);
            break;
          default:
            jj_la1[98] = jj_gen;
            ;
          }
           n9.addNode(n14);
           n4 = new NodeChoice(n9, 1);
          break;
        default:
          jj_la1[99] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      n17 = jj_consume_token(SEMICOLON);
             n16 = JTBToolkit.makeNodeToken(n17);
      switch (jj_nt.kind) {
      case NUMBER:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case ALIGNOF:
      case SIZEOF:
      case GENERIC:
      case IDENTIFIER:
      case INC:
      case DEC:
      case RBL:
      case STAR:
      case PLUS:
      case MINUS:
      case EXCL:
      case AMP:
      case TILDE:
        n19 = Expression();
        n18.addNode(n19);
        break;
      default:
        jj_la1[100] = jj_gen;
        ;
      }
      n21 = jj_consume_token(RBR);
             n20 = JTBToolkit.makeNodeToken(n21);
      n22 = Statement();
     {if (true) return new ForStatement(n0,n2,n4,n16,n18,n20,n22);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ForStatement");
    }
  }

  final public JumpStatement JumpStatement() throws ParseException {
    trace_call("JumpStatement");
    try {
   NodeChoice n0;
   NodeSequence n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   NodeToken n6;
   Token n7;
   NodeSequence n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
   NodeSequence n13;
   NodeToken n14;
   Token n15;
   NodeToken n16;
   Token n17;
   ReturnStatement n18;
      switch (jj_nt.kind) {
      case GOTO:
           n1 = new NodeSequence(3);
        n3 = jj_consume_token(GOTO);
                     n2 = JTBToolkit.makeNodeToken(n3);
           n1.addNode(n2);
        n5 = jj_consume_token(IDENTIFIER);
                           n4 = JTBToolkit.makeNodeToken(n5);
           n1.addNode(n4);
        n7 = jj_consume_token(SEMICOLON);
                  n6 = JTBToolkit.makeNodeToken(n7);
           n1.addNode(n6);
           n0 = new NodeChoice(n1, 0);
        break;
      case CONTINUE:
           n8 = new NodeSequence(2);
        n10 = jj_consume_token(CONTINUE);
                          n9 = JTBToolkit.makeNodeToken(n10);
           n8.addNode(n9);
        n12 = jj_consume_token(SEMICOLON);
                   n11 = JTBToolkit.makeNodeToken(n12);
           n8.addNode(n11);
           n0 = new NodeChoice(n8, 1);
        break;
      case BREAK:
           n13 = new NodeSequence(2);
        n15 = jj_consume_token(BREAK);
                       n14 = JTBToolkit.makeNodeToken(n15);
           n13.addNode(n14);
        n17 = jj_consume_token(SEMICOLON);
                   n16 = JTBToolkit.makeNodeToken(n17);
           n13.addNode(n16);
           n0 = new NodeChoice(n13, 2);
        break;
      case RETURN:
        n18 = ReturnStatement();
           n0 = new NodeChoice(n18, 3);
        break;
      default:
        jj_la1[101] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     {if (true) return new JumpStatement(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JumpStatement");
    }
  }

  final public ReturnStatement ReturnStatement() throws ParseException {
    trace_call("ReturnStatement");
    try {
   NodeToken n0;
   Token n1;
   NodeOptional n2 = new NodeOptional();
   Expression n3;
   NodeToken n4;
   Token n5;
      n1 = jj_consume_token(RETURN);
                 n0 = JTBToolkit.makeNodeToken(n1);
      switch (jj_nt.kind) {
      case NUMBER:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case ALIGNOF:
      case SIZEOF:
      case GENERIC:
      case IDENTIFIER:
      case INC:
      case DEC:
      case RBL:
      case STAR:
      case PLUS:
      case MINUS:
      case EXCL:
      case AMP:
      case TILDE:
        n3 = Expression();
        n2.addNode(n3);
        break;
      default:
        jj_la1[102] = jj_gen;
        ;
      }
      n5 = jj_consume_token(SEMICOLON);
            n4 = JTBToolkit.makeNodeToken(n5);
     {if (true) return new ReturnStatement(n0,n2,n4);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ReturnStatement");
    }
  }

  final public TranslationUnit TranslationUnit() throws ParseException {
    trace_call("TranslationUnit");
    try {
   NodeList n0 = new NodeList();
   ExternalDeclaration n1;
      label_18:
      while (true) {
        n1 = ExternalDeclaration();
        n0.addNode(n1);
        if (jj_2_43(1)) {
          ;
        } else {
          break label_18;
        }
      }
     n0.nodes.trimToSize();
     {if (true) return new TranslationUnit(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("TranslationUnit");
    }
  }

  final public ExternalDeclaration ExternalDeclaration() throws ParseException {
    trace_call("ExternalDeclaration");
    try {
   NodeChoice n0;
   FunctionDefinition n1;
   Declaration n2;
      if (jj_2_44(2147483647)) {
        n1 = FunctionDefinition();
           n0 = new NodeChoice(n1, 0);
      } else if (jj_2_45(1)) {
        n2 = Declaration();
           n0 = new NodeChoice(n2, 1);
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
     {if (true) return new ExternalDeclaration(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ExternalDeclaration");
    }
  }

  final public FunctionDefinition FunctionDefinition() throws ParseException {
    trace_call("FunctionDefinition");
    try {
   NodeOptional n0 = new NodeOptional();
   DeclarationSpecifiers n1;
   Declarator n2;
   NodeOptional n3 = new NodeOptional();
   DeclarationList n4;
   CompoundStatement n5;
      if (jj_2_46(2147483647)) {
        n1 = DeclarationSpecifiers();
        n0.addNode(n1);
      } else {
        ;
      }
      n2 = Declarator();
      if (jj_2_47(1)) {
        n4 = DeclarationList();
        n3.addNode(n4);
      } else {
        ;
      }
      n5 = CompoundStatement();
     {if (true) return new FunctionDefinition(n0,n2,n3,n5);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("FunctionDefinition");
    }
  }

  final public DeclarationList DeclarationList() throws ParseException {
    trace_call("DeclarationList");
    try {
   NodeList n0 = new NodeList();
   Declaration n1;
      label_19:
      while (true) {
        n1 = Declaration();
        n0.addNode(n1);
        if (jj_2_48(2147483647)) {
          ;
        } else {
          break label_19;
        }
      }
     n0.nodes.trimToSize();
     {if (true) return new DeclarationList(n0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("DeclarationList");
    }
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(27, xla); }
  }

  private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(28, xla); }
  }

  private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(29, xla); }
  }

  private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_31(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(30, xla); }
  }

  private boolean jj_2_32(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_32(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(31, xla); }
  }

  private boolean jj_2_33(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_33(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(32, xla); }
  }

  private boolean jj_2_34(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_34(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(33, xla); }
  }

  private boolean jj_2_35(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_35(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(34, xla); }
  }

  private boolean jj_2_36(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_36(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(35, xla); }
  }

  private boolean jj_2_37(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_37(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(36, xla); }
  }

  private boolean jj_2_38(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_38(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(37, xla); }
  }

  private boolean jj_2_39(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_39(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(38, xla); }
  }

  private boolean jj_2_40(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_40(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(39, xla); }
  }

  private boolean jj_2_41(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_41(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(40, xla); }
  }

  private boolean jj_2_42(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_42(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(41, xla); }
  }

  private boolean jj_2_43(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_43(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(42, xla); }
  }

  private boolean jj_2_44(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_44(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(43, xla); }
  }

  private boolean jj_2_45(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_45(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(44, xla); }
  }

  private boolean jj_2_46(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_46(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(45, xla); }
  }

  private boolean jj_2_47(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_47(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(46, xla); }
  }

  private boolean jj_2_48(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_48(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(47, xla); }
  }

  private boolean jj_3R_280() {
    if (jj_3R_288()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_289()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_29() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_240() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_250()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_15() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_29()) jj_scanpos = xsp;
    if (jj_scan_token(CBL)) return true;
    if (jj_3R_30()) return true;
    if (jj_scan_token(CBR)) return true;
    return false;
  }

  private boolean jj_3R_155() {
    if (jj_scan_token(WHILE)) return true;
    if (jj_scan_token(RBL)) return true;
    if (jj_3R_212()) return true;
    if (jj_scan_token(RBR)) return true;
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3_27() {
    if (jj_3R_42()) return true;
    return false;
  }

  private boolean jj_3R_305() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_219() {
    if (jj_3R_44()) return true;
    return false;
  }

  private boolean jj_3R_139() {
    if (jj_3R_192()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_15()) {
    jj_scanpos = xsp;
    if (jj_3R_193()) return true;
    }
    return false;
  }

  private boolean jj_3R_304() {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3R_196() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_219()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_195() {
    if (jj_3R_42()) return true;
    return false;
  }

  private boolean jj_3R_298() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_304()) {
    jj_scanpos = xsp;
    if (jj_3R_305()) return true;
    }
    if (jj_3R_288()) return true;
    return false;
  }

  private boolean jj_3R_154() {
    if (jj_scan_token(SWITCH)) return true;
    if (jj_scan_token(RBL)) return true;
    if (jj_3R_212()) return true;
    if (jj_scan_token(RBR)) return true;
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3R_288() {
    if (jj_3R_297()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_298()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_41() {
    if (jj_3R_26()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_195()) {
    jj_scanpos = xsp;
    if (jj_3R_196()) return true;
    }
    return false;
  }

  private boolean jj_3R_94() {
    if (jj_3R_141()) return true;
    return false;
  }

  private boolean jj_3R_93() {
    if (jj_3R_140()) return true;
    return false;
  }

  private boolean jj_3R_92() {
    if (jj_3R_139()) return true;
    return false;
  }

  private boolean jj_3R_91() {
    if (jj_3R_138()) return true;
    return false;
  }

  private boolean jj_3R_309() {
    if (jj_scan_token(MOD)) return true;
    return false;
  }

  private boolean jj_3R_90() {
    if (jj_scan_token(COMPLEX)) return true;
    return false;
  }

  private boolean jj_3_26() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_41()) return true;
    return false;
  }

  private boolean jj_3_41() {
    if (jj_scan_token(ELSE)) return true;
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3R_308() {
    if (jj_scan_token(SLASH)) return true;
    return false;
  }

  private boolean jj_3R_89() {
    if (jj_scan_token(BOOL)) return true;
    return false;
  }

  private boolean jj_3R_307() {
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3R_99() {
    if (jj_3R_41()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_26()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_88() {
    if (jj_scan_token(UNSIGNED)) return true;
    return false;
  }

  private boolean jj_3R_87() {
    if (jj_scan_token(SIGNED)) return true;
    return false;
  }

  private boolean jj_3R_153() {
    if (jj_scan_token(IF)) return true;
    if (jj_scan_token(RBL)) return true;
    if (jj_3R_212()) return true;
    if (jj_scan_token(RBR)) return true;
    if (jj_3R_50()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_41()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_86() {
    if (jj_scan_token(DOUBLE)) return true;
    return false;
  }

  private boolean jj_3R_303() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_307()) {
    jj_scanpos = xsp;
    if (jj_3R_308()) {
    jj_scanpos = xsp;
    if (jj_3R_309()) return true;
    }
    }
    if (jj_3R_297()) return true;
    return false;
  }

  private boolean jj_3R_85() {
    if (jj_scan_token(FLOAT)) return true;
    return false;
  }

  private boolean jj_3R_84() {
    if (jj_scan_token(LONG)) return true;
    return false;
  }

  private boolean jj_3R_297() {
    if (jj_3R_23()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_303()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_83() {
    if (jj_scan_token(INT)) return true;
    return false;
  }

  private boolean jj_3R_82() {
    if (jj_scan_token(SHORT)) return true;
    return false;
  }

  private boolean jj_3R_239() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_scan_token(ELLIPSIS)) return true;
    return false;
  }

  private boolean jj_3R_81() {
    if (jj_scan_token(CHAR)) return true;
    return false;
  }

  private boolean jj_3R_80() {
    if (jj_scan_token(VOID)) return true;
    return false;
  }

  private boolean jj_3R_40() {
    if (jj_3R_99()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_239()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_202() {
    if (jj_3R_212()) return true;
    return false;
  }

  private boolean jj_3R_152() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_202()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_27() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_80()) {
    jj_scanpos = xsp;
    if (jj_3R_81()) {
    jj_scanpos = xsp;
    if (jj_3R_82()) {
    jj_scanpos = xsp;
    if (jj_3R_83()) {
    jj_scanpos = xsp;
    if (jj_3R_84()) {
    jj_scanpos = xsp;
    if (jj_3R_85()) {
    jj_scanpos = xsp;
    if (jj_3R_86()) {
    jj_scanpos = xsp;
    if (jj_3R_87()) {
    jj_scanpos = xsp;
    if (jj_3R_88()) {
    jj_scanpos = xsp;
    if (jj_3R_89()) {
    jj_scanpos = xsp;
    if (jj_3R_90()) {
    jj_scanpos = xsp;
    if (jj_3R_91()) {
    jj_scanpos = xsp;
    if (jj_3R_92()) {
    jj_scanpos = xsp;
    if (jj_3R_93()) {
    jj_scanpos = xsp;
    jj_lookingAhead = true;
    jj_semLA = isType(getToken(1).image);
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_94()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_59() {
    if (jj_3R_24()) return true;
    return false;
  }

  private boolean jj_3_6() {
    if (jj_scan_token(RBL)) return true;
    if (jj_3R_20()) return true;
    if (jj_scan_token(RBR)) return true;
    if (jj_3R_23()) return true;
    return false;
  }

  private boolean jj_3R_98() {
    if (jj_3R_131()) return true;
    return false;
  }

  private boolean jj_3R_58() {
    if (jj_scan_token(RBL)) return true;
    if (jj_3R_20()) return true;
    if (jj_scan_token(RBR)) return true;
    if (jj_3R_23()) return true;
    return false;
  }

  private boolean jj_3R_110() {
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3R_38() {
    Token xsp;
    if (jj_3R_98()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_98()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_40() {
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3R_48() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_40()) {
    jj_scanpos = xsp;
    if (jj_3R_110()) return true;
    }
    return false;
  }

  private boolean jj_3R_23() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_58()) {
    jj_scanpos = xsp;
    if (jj_3R_59()) return true;
    }
    return false;
  }

  private boolean jj_3R_103() {
    if (jj_3R_43()) return true;
    return false;
  }

  private boolean jj_3R_102() {
    if (jj_3R_38()) return true;
    return false;
  }

  private boolean jj_3_39() {
    if (jj_3R_48()) return true;
    return false;
  }

  private boolean jj_3R_43() {
    if (jj_scan_token(STAR)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_102()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_103()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_47() {
    Token xsp;
    if (jj_3_39()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_39()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_177() {
    if (jj_scan_token(EXCL)) return true;
    return false;
  }

  private boolean jj_3R_183() {
    if (jj_scan_token(TYPEDEF)) return true;
    return false;
  }

  private boolean jj_3R_176() {
    if (jj_scan_token(TILDE)) return true;
    return false;
  }

  private boolean jj_3R_182() {
    if (jj_scan_token(REGISTER)) return true;
    return false;
  }

  private boolean jj_3R_175() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_181() {
    if (jj_scan_token(AUTO)) return true;
    return false;
  }

  private boolean jj_3R_174() {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3R_180() {
    if (jj_scan_token(THREADLOCAL)) return true;
    return false;
  }

  private boolean jj_3R_173() {
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3_38() {
    if (jj_3R_47()) return true;
    return false;
  }

  private boolean jj_3R_179() {
    if (jj_scan_token(STATIC)) return true;
    return false;
  }

  private boolean jj_3R_172() {
    if (jj_scan_token(AMP)) return true;
    return false;
  }

  private boolean jj_3R_178() {
    if (jj_scan_token(EXTERN)) return true;
    return false;
  }

  private boolean jj_3R_122() {
    if (jj_scan_token(CBL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_38()) jj_scanpos = xsp;
    if (jj_scan_token(CBR)) return true;
    return false;
  }

  private boolean jj_3R_223() {
    if (jj_3R_240()) return true;
    return false;
  }

  private boolean jj_3R_128() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_172()) {
    jj_scanpos = xsp;
    if (jj_3R_173()) {
    jj_scanpos = xsp;
    if (jj_3R_174()) {
    jj_scanpos = xsp;
    if (jj_3R_175()) {
    jj_scanpos = xsp;
    if (jj_3R_176()) {
    jj_scanpos = xsp;
    if (jj_3R_177()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_130() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_178()) {
    jj_scanpos = xsp;
    if (jj_3R_179()) {
    jj_scanpos = xsp;
    if (jj_3R_180()) {
    jj_scanpos = xsp;
    if (jj_3R_181()) {
    jj_scanpos = xsp;
    if (jj_3R_182()) {
    jj_scanpos = xsp;
    if (jj_3R_183()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_198() {
    if (jj_scan_token(RBL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_223()) jj_scanpos = xsp;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3_25() {
    if (jj_scan_token(RBL)) return true;
    if (jj_3R_40()) return true;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3R_151() {
    if (jj_scan_token(DFAULT)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3R_238() {
    if (jj_3R_201()) return true;
    return false;
  }

  private boolean jj_3R_222() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_238()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_39() {
    if (jj_3R_38()) return true;
    return false;
  }

  private boolean jj_3R_241() {
    if (jj_scan_token(ASSIGNMENT)) return true;
    if (jj_3R_45()) return true;
    return false;
  }

  private boolean jj_3R_64() {
    if (jj_scan_token(ALIGNOF)) return true;
    if (jj_scan_token(RBL)) return true;
    if (jj_3R_20()) return true;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3R_150() {
    if (jj_scan_token(CASE)) return true;
    if (jj_3R_201()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3R_129() {
    if (jj_3R_24()) return true;
    return false;
  }

  private boolean jj_3_24() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_39()) jj_scanpos = xsp;
    if (jj_scan_token(STAR)) return true;
    if (jj_scan_token(SBR)) return true;
    return false;
  }

  private boolean jj_3_23() {
    if (jj_3R_38()) return true;
    if (jj_scan_token(STATIC)) return true;
    return false;
  }

  private boolean jj_3R_225() {
    if (jj_3R_42()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_241()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_4() {
    if (jj_scan_token(RBL)) return true;
    if (jj_3R_20()) return true;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3R_221() {
    if (jj_3R_38()) return true;
    if (jj_scan_token(STATIC)) return true;
    if (jj_3R_54()) return true;
    return false;
  }

  private boolean jj_3R_109() {
    if (jj_3R_151()) return true;
    return false;
  }

  private boolean jj_3R_237() {
    if (jj_3R_38()) return true;
    return false;
  }

  private boolean jj_3R_108() {
    if (jj_3R_150()) return true;
    return false;
  }

  private boolean jj_3R_63() {
    if (jj_scan_token(SIZEOF)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_4()) {
    jj_scanpos = xsp;
    if (jj_3R_129()) return true;
    }
    return false;
  }

  private boolean jj_3R_220() {
    if (jj_scan_token(STATIC)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_237()) jj_scanpos = xsp;
    if (jj_3R_54()) return true;
    return false;
  }

  private boolean jj_3R_107() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3R_62() {
    if (jj_3R_128()) return true;
    if (jj_3R_23()) return true;
    return false;
  }

  private boolean jj_3R_226() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_225()) return true;
    return false;
  }

  private boolean jj_3R_197() {
    if (jj_scan_token(SBL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_220()) {
    jj_scanpos = xsp;
    if (jj_3R_221()) {
    jj_scanpos = xsp;
    if (jj_3_24()) {
    jj_scanpos = xsp;
    if (jj_3R_222()) return true;
    }
    }
    }
    if (jj_scan_token(SBR)) return true;
    return false;
  }

  private boolean jj_3R_46() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_107()) {
    jj_scanpos = xsp;
    if (jj_3R_108()) {
    jj_scanpos = xsp;
    if (jj_3R_109()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_61() {
    if (jj_scan_token(DEC)) return true;
    if (jj_3R_24()) return true;
    return false;
  }

  private boolean jj_3R_207() {
    if (jj_3R_225()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_226()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_147() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_197()) {
    jj_scanpos = xsp;
    if (jj_3_25()) {
    jj_scanpos = xsp;
    if (jj_3R_198()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_60() {
    if (jj_scan_token(INC)) return true;
    if (jj_3R_24()) return true;
    return false;
  }

  private boolean jj_3_13() {
    if (jj_3R_26()) return true;
    return false;
  }

  private boolean jj_3_5() {
    if (jj_3R_22()) return true;
    return false;
  }

  private boolean jj_3R_24() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_5()) {
    jj_scanpos = xsp;
    if (jj_3R_60()) {
    jj_scanpos = xsp;
    if (jj_3R_61()) {
    jj_scanpos = xsp;
    if (jj_3R_62()) {
    jj_scanpos = xsp;
    if (jj_3R_63()) {
    jj_scanpos = xsp;
    if (jj_3R_64()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_137() {
    if (jj_3R_26()) return true;
    return false;
  }

  private boolean jj_3R_119() {
    if (jj_3R_158()) return true;
    return false;
  }

  private boolean jj_3_12() {
    if (jj_3R_26()) return true;
    return false;
  }

  private boolean jj_3R_146() {
    if (jj_scan_token(RBL)) return true;
    if (jj_3R_42()) return true;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3R_118() {
    if (jj_3R_157()) return true;
    return false;
  }

  private boolean jj_3R_117() {
    if (jj_3R_156()) return true;
    return false;
  }

  private boolean jj_3R_79() {
    if (jj_3R_133()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_137()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_116() {
    if (jj_3R_155()) return true;
    return false;
  }

  private boolean jj_3R_136() {
    if (jj_3R_26()) return true;
    return false;
  }

  private boolean jj_3_11() {
    if (jj_3R_26()) return true;
    return false;
  }

  private boolean jj_3R_115() {
    if (jj_3R_154()) return true;
    return false;
  }

  private boolean jj_3R_145() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_114() {
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3R_78() {
    if (jj_3R_132()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_136()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_113() {
    if (jj_3R_152()) return true;
    return false;
  }

  private boolean jj_3R_112() {
    if (jj_3R_122()) return true;
    return false;
  }

  private boolean jj_3R_135() {
    if (jj_3R_26()) return true;
    return false;
  }

  private boolean jj_3R_101() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_145()) {
    jj_scanpos = xsp;
    if (jj_3R_146()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_147()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_10() {
    if (jj_3R_26()) return true;
    return false;
  }

  private boolean jj_3_37() {
    if (jj_3R_46()) return true;
    return false;
  }

  private boolean jj_3R_77() {
    if (jj_3R_131()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_135()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_28() {
    if (jj_3R_26()) return true;
    return false;
  }

  private boolean jj_3R_50() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_37()) {
    jj_scanpos = xsp;
    if (jj_3R_112()) {
    jj_scanpos = xsp;
    if (jj_3R_113()) {
    jj_scanpos = xsp;
    if (jj_3R_114()) {
    jj_scanpos = xsp;
    if (jj_3R_115()) {
    jj_scanpos = xsp;
    if (jj_3R_116()) {
    jj_scanpos = xsp;
    if (jj_3R_117()) {
    jj_scanpos = xsp;
    if (jj_3R_118()) {
    jj_scanpos = xsp;
    if (jj_3R_119()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_9() {
    if (jj_3R_26()) return true;
    return false;
  }

  private boolean jj_3_14() {
    if (jj_3R_27()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_28()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_55() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_54()) return true;
    return false;
  }

  private boolean jj_3R_134() {
    if (jj_3R_26()) return true;
    return false;
  }

  private boolean jj_3R_21() {
    if (jj_3R_54()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_55()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_76() {
    if (jj_3R_130()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_134()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_26() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_76()) {
    jj_scanpos = xsp;
    if (jj_3_14()) {
    jj_scanpos = xsp;
    if (jj_3R_77()) {
    jj_scanpos = xsp;
    if (jj_3R_78()) {
    jj_scanpos = xsp;
    if (jj_3R_79()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_142() {
    if (jj_scan_token(STATICASSERT)) return true;
    if (jj_scan_token(RBL)) return true;
    if (jj_3R_201()) return true;
    if (jj_scan_token(COMMA)) return true;
    if (jj_scan_token(STRING_LITERAL)) return true;
    if (jj_scan_token(RBR)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_171() {
    if (jj_scan_token(DEC)) return true;
    return false;
  }

  private boolean jj_3R_170() {
    if (jj_scan_token(INC)) return true;
    return false;
  }

  private boolean jj_3R_169() {
    if (jj_scan_token(ARROW)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_3R_21()) return true;
    return false;
  }

  private boolean jj_3R_168() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_100() {
    if (jj_3R_43()) return true;
    return false;
  }

  private boolean jj_3R_275() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_111() {
    if (jj_3R_142()) return true;
    return false;
  }

  private boolean jj_3R_42() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_100()) jj_scanpos = xsp;
    if (jj_3R_101()) return true;
    return false;
  }

  private boolean jj_3R_214() {
    if (jj_3R_21()) return true;
    return false;
  }

  private boolean jj_3R_159() {
    if (jj_3R_207()) return true;
    return false;
  }

  private boolean jj_3R_274() {
    if (jj_scan_token(SBL)) return true;
    if (jj_3R_201()) return true;
    if (jj_scan_token(SBR)) return true;
    return false;
  }

  private boolean jj_3R_167() {
    if (jj_scan_token(RBL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_214()) jj_scanpos = xsp;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3_8() {
    if (jj_3R_26()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_159()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_191() {
    if (jj_3R_201()) return true;
    return false;
  }

  private boolean jj_3R_270() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_274()) {
    jj_scanpos = xsp;
    if (jj_3R_275()) return true;
    }
    return false;
  }

  private boolean jj_3R_190() {
    if (jj_3R_141()) return true;
    return false;
  }

  private boolean jj_3R_166() {
    if (jj_scan_token(SBL)) return true;
    if (jj_3R_212()) return true;
    if (jj_scan_token(SBR)) return true;
    return false;
  }

  private boolean jj_3R_49() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_8()) {
    jj_scanpos = xsp;
    if (jj_3R_111()) return true;
    }
    return false;
  }

  private boolean jj_3R_127() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_166()) {
    jj_scanpos = xsp;
    if (jj_3R_167()) {
    jj_scanpos = xsp;
    if (jj_3R_168()) {
    jj_scanpos = xsp;
    if (jj_3R_169()) {
    jj_scanpos = xsp;
    if (jj_3R_170()) {
    jj_scanpos = xsp;
    if (jj_3R_171()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_133() {
    if (jj_scan_token(ALIGNAS)) return true;
    if (jj_scan_token(RBL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    jj_lookingAhead = true;
    jj_semLA = isType(getToken(1).image);
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_190()) {
    jj_scanpos = xsp;
    if (jj_3R_191()) return true;
    }
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3R_57() {
    if (jj_3R_126()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_127()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_216() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_201() {
    if (jj_3R_160()) return true;
    return false;
  }

  private boolean jj_3R_265() {
    if (jj_3R_270()) return true;
    return false;
  }

  private boolean jj_3R_258() {
    Token xsp;
    if (jj_3R_265()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_265()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_189() {
    if (jj_scan_token(NORETURN)) return true;
    return false;
  }

  private boolean jj_3R_188() {
    if (jj_scan_token(INLINE)) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_scan_token(RBL)) return true;
    if (jj_3R_20()) return true;
    if (jj_scan_token(RBR)) return true;
    if (jj_scan_token(CBL)) return true;
    if (jj_3R_215()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_216()) jj_scanpos = xsp;
    if (jj_scan_token(CBR)) return true;
    return false;
  }

  private boolean jj_3R_233() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_54()) return true;
    return false;
  }

  private boolean jj_3R_22() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_3()) {
    jj_scanpos = xsp;
    if (jj_3R_57()) return true;
    }
    return false;
  }

  private boolean jj_3R_132() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_188()) {
    jj_scanpos = xsp;
    if (jj_3R_189()) return true;
    }
    return false;
  }

  private boolean jj_3R_249() {
    if (jj_3R_258()) return true;
    if (jj_scan_token(ASSIGNMENT)) return true;
    return false;
  }

  private boolean jj_3R_212() {
    if (jj_3R_54()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_233()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_187() {
    if (jj_scan_token(ATOMIC)) return true;
    return false;
  }

  private boolean jj_3R_186() {
    if (jj_scan_token(VOLATILE)) return true;
    return false;
  }

  private boolean jj_3R_75() {
    if (jj_scan_token(OR_EQ)) return true;
    return false;
  }

  private boolean jj_3R_185() {
    if (jj_scan_token(RESTRICT)) return true;
    return false;
  }

  private boolean jj_3_36() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_45()) return true;
    return false;
  }

  private boolean jj_3R_74() {
    if (jj_scan_token(XOR_EQ)) return true;
    return false;
  }

  private boolean jj_3R_184() {
    if (jj_scan_token(CONST)) return true;
    return false;
  }

  private boolean jj_3R_73() {
    if (jj_scan_token(AND_EQ)) return true;
    return false;
  }

  private boolean jj_3R_235() {
    if (jj_3R_249()) return true;
    return false;
  }

  private boolean jj_3R_72() {
    if (jj_scan_token(RSH_EQ)) return true;
    return false;
  }

  private boolean jj_3R_215() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_235()) jj_scanpos = xsp;
    if (jj_3R_45()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_36()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_71() {
    if (jj_scan_token(LSH_EQ)) return true;
    return false;
  }

  private boolean jj_3R_131() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_184()) {
    jj_scanpos = xsp;
    if (jj_3R_185()) {
    jj_scanpos = xsp;
    if (jj_3R_186()) {
    jj_scanpos = xsp;
    if (jj_3R_187()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_70() {
    if (jj_scan_token(SUB_EQ)) return true;
    return false;
  }

  private boolean jj_3R_69() {
    if (jj_scan_token(PLUS_EQ)) return true;
    return false;
  }

  private boolean jj_3R_68() {
    if (jj_scan_token(MOD_EQ)) return true;
    return false;
  }

  private boolean jj_3R_67() {
    if (jj_scan_token(DIV_EQ)) return true;
    return false;
  }

  private boolean jj_3R_66() {
    if (jj_scan_token(MULT_EQ)) return true;
    return false;
  }

  private boolean jj_3R_259() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_65() {
    if (jj_scan_token(ASSIGNMENT)) return true;
    return false;
  }

  private boolean jj_3R_25() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_65()) {
    jj_scanpos = xsp;
    if (jj_3R_66()) {
    jj_scanpos = xsp;
    if (jj_3R_67()) {
    jj_scanpos = xsp;
    if (jj_3R_68()) {
    jj_scanpos = xsp;
    if (jj_3R_69()) {
    jj_scanpos = xsp;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) {
    jj_scanpos = xsp;
    if (jj_3R_72()) {
    jj_scanpos = xsp;
    if (jj_3R_73()) {
    jj_scanpos = xsp;
    if (jj_3R_74()) {
    jj_scanpos = xsp;
    if (jj_3R_75()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_236() {
    return false;
  }

  private boolean jj_3R_138() {
    if (jj_scan_token(ATOMIC)) return true;
    if (jj_scan_token(RBL)) return true;
    jj_lookingAhead = true;
    jj_semLA = isType(getToken(1).image);
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_236()) return true;
    if (jj_3R_141()) return true;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3_1() {
    if (jj_3R_20()) return true;
    return false;
  }

  private boolean jj_3R_106() {
    if (jj_scan_token(CBL)) return true;
    if (jj_3R_215()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_259()) jj_scanpos = xsp;
    if (jj_scan_token(CBR)) return true;
    return false;
  }

  private boolean jj_3R_271() {
    if (jj_scan_token(DFAULT)) return true;
    return false;
  }

  private boolean jj_3R_105() {
    if (jj_3R_54()) return true;
    return false;
  }

  private boolean jj_3R_266() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_271()) {
    jj_scanpos = xsp;
    if (jj_3_1()) return true;
    }
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_54()) return true;
    return false;
  }

  private boolean jj_3R_45() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_105()) {
    jj_scanpos = xsp;
    if (jj_3R_106()) return true;
    }
    return false;
  }

  private boolean jj_3R_144() {
    if (jj_scan_token(ASSIGNMENT)) return true;
    if (jj_3R_201()) return true;
    return false;
  }

  private boolean jj_3R_37() {
    if (jj_3R_97()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_144()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_7() {
    if (jj_3R_24()) return true;
    if (jj_3R_25()) return true;
    return false;
  }

  private boolean jj_3R_125() {
    if (jj_3R_160()) return true;
    return false;
  }

  private boolean jj_3R_267() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_266()) return true;
    return false;
  }

  private boolean jj_3R_141() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_260() {
    if (jj_3R_266()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_267()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_124() {
    if (jj_3R_24()) return true;
    if (jj_3R_25()) return true;
    if (jj_3R_54()) return true;
    return false;
  }

  private boolean jj_3R_54() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_124()) {
    jj_scanpos = xsp;
    if (jj_3R_125()) return true;
    }
    return false;
  }

  private boolean jj_3_22() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_37()) return true;
    return false;
  }

  private boolean jj_3R_264() {
    if (jj_3R_38()) return true;
    return false;
  }

  private boolean jj_3R_35() {
    if (jj_3R_37()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_22()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_257() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_264()) jj_scanpos = xsp;
    if (jj_3R_54()) return true;
    return false;
  }

  private boolean jj_3_48() {
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3_35() {
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3_34() {
    if (jj_3R_38()) return true;
    if (jj_scan_token(STATIC)) return true;
    return false;
  }

  private boolean jj_3R_213() {
    if (jj_scan_token(GENERIC)) return true;
    if (jj_scan_token(RBL)) return true;
    if (jj_3R_54()) return true;
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_260()) return true;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3R_229() {
    if (jj_scan_token(QEM)) return true;
    if (jj_3R_212()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_160()) return true;
    return false;
  }

  private boolean jj_3R_123() {
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3R_194() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_256() {
    if (jj_3R_38()) return true;
    if (jj_scan_token(STATIC)) return true;
    if (jj_3R_54()) return true;
    return false;
  }

  private boolean jj_3R_53() {
    Token xsp;
    if (jj_3R_123()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_123()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_36() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_263() {
    if (jj_3R_38()) return true;
    return false;
  }

  private boolean jj_3_46() {
    if (jj_3R_26()) return true;
    return false;
  }

  private boolean jj_3R_165() {
    if (jj_3R_213()) return true;
    return false;
  }

  private boolean jj_3R_209() {
    if (jj_3R_229()) return true;
    return false;
  }

  private boolean jj_3R_255() {
    if (jj_scan_token(STATIC)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_263()) jj_scanpos = xsp;
    if (jj_3R_54()) return true;
    return false;
  }

  private boolean jj_3R_34() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3_47() {
    if (jj_3R_53()) return true;
    return false;
  }

  private boolean jj_3R_160() {
    if (jj_3R_208()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_209()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_21() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_34()) jj_scanpos = xsp;
    if (jj_scan_token(CBL)) return true;
    if (jj_3R_35()) return true;
    xsp = jj_scanpos;
    if (jj_3R_36()) jj_scanpos = xsp;
    if (jj_scan_token(CBR)) return true;
    return false;
  }

  private boolean jj_3R_164() {
    if (jj_scan_token(RBL)) return true;
    if (jj_3R_212()) return true;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3R_121() {
    if (jj_3R_26()) return true;
    return false;
  }

  private boolean jj_3R_248() {
    if (jj_scan_token(SBL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_255()) {
    jj_scanpos = xsp;
    if (jj_3R_256()) {
    jj_scanpos = xsp;
    if (jj_3_35()) {
    jj_scanpos = xsp;
    if (jj_3R_257()) return true;
    }
    }
    }
    if (jj_scan_token(SBR)) return true;
    return false;
  }

  private boolean jj_3R_163() {
    if (jj_3R_211()) return true;
    return false;
  }

  private boolean jj_3R_52() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_121()) jj_scanpos = xsp;
    if (jj_3R_42()) return true;
    xsp = jj_scanpos;
    if (jj_3_47()) jj_scanpos = xsp;
    if (jj_3R_122()) return true;
    return false;
  }

  private boolean jj_3R_162() {
    if (jj_3R_210()) return true;
    return false;
  }

  private boolean jj_3R_140() {
    if (jj_scan_token(ENUM)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_21()) {
    jj_scanpos = xsp;
    if (jj_3R_194()) return true;
    }
    return false;
  }

  private boolean jj_3_33() {
    if (jj_3R_40()) return true;
    return false;
  }

  private boolean jj_3R_161() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_126() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_161()) {
    jj_scanpos = xsp;
    if (jj_3R_162()) {
    jj_scanpos = xsp;
    if (jj_3R_163()) {
    jj_scanpos = xsp;
    if (jj_3R_164()) {
    jj_scanpos = xsp;
    if (jj_3R_165()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_228() {
    if (jj_scan_token(LOR)) return true;
    if (jj_3R_208()) return true;
    return false;
  }

  private boolean jj_3_44() {
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_247() {
    if (jj_scan_token(RBL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_33()) jj_scanpos = xsp;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3R_208() {
    if (jj_3R_227()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_228()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_45() {
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3R_234() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_247()) {
    jj_scanpos = xsp;
    if (jj_3R_248()) return true;
    }
    return false;
  }

  private boolean jj_3R_120() {
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_254() {
    if (jj_3R_38()) return true;
    return false;
  }

  private boolean jj_3R_51() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_120()) {
    jj_scanpos = xsp;
    if (jj_3_45()) return true;
    }
    return false;
  }

  private boolean jj_3R_246() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_254()) jj_scanpos = xsp;
    if (jj_3R_54()) return true;
    return false;
  }

  private boolean jj_3R_232() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3_31() {
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3_30() {
    if (jj_3R_38()) return true;
    if (jj_scan_token(STATIC)) return true;
    return false;
  }

  private boolean jj_3R_302() {
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_201()) return true;
    return false;
  }

  private boolean jj_3R_243() {
    if (jj_scan_token(LAND)) return true;
    if (jj_3R_227()) return true;
    return false;
  }

  private boolean jj_3R_211() {
    Token xsp;
    if (jj_3R_232()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_232()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_227() {
    if (jj_3R_242()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_243()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_306() {
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_201()) return true;
    return false;
  }

  private boolean jj_3_43() {
    if (jj_3R_51()) return true;
    return false;
  }

  private boolean jj_3R_245() {
    if (jj_3R_38()) return true;
    if (jj_scan_token(STATIC)) return true;
    if (jj_3R_54()) return true;
    return false;
  }

  private boolean jj_3R_253() {
    if (jj_3R_38()) return true;
    return false;
  }

  private boolean jj_3R_301() {
    if (jj_3R_42()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_306()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_97() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_294() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_301()) {
    jj_scanpos = xsp;
    if (jj_3R_302()) return true;
    }
    return false;
  }

  private boolean jj_3R_244() {
    if (jj_scan_token(STATIC)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_253()) jj_scanpos = xsp;
    if (jj_3R_54()) return true;
    return false;
  }

  private boolean jj_3R_296() {
    if (jj_3R_212()) return true;
    return false;
  }

  private boolean jj_3R_252() {
    if (jj_scan_token(PIPE)) return true;
    if (jj_3R_242()) return true;
    return false;
  }

  private boolean jj_3R_231() {
    if (jj_scan_token(CHARACTER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_224() {
    if (jj_scan_token(RETURN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_296()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_242() {
    if (jj_3R_251()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_252()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_230() {
    if (jj_scan_token(NUMBER)) return true;
    return false;
  }

  private boolean jj_3R_200() {
    if (jj_scan_token(SBL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_244()) {
    jj_scanpos = xsp;
    if (jj_3R_245()) {
    jj_scanpos = xsp;
    if (jj_3_31()) {
    jj_scanpos = xsp;
    if (jj_3R_246()) return true;
    }
    }
    }
    if (jj_scan_token(SBR)) return true;
    return false;
  }

  private boolean jj_3R_210() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_230()) {
    jj_scanpos = xsp;
    if (jj_3R_231()) return true;
    }
    return false;
  }

  private boolean jj_3_29() {
    if (jj_3R_40()) return true;
    return false;
  }

  private boolean jj_3R_199() {
    if (jj_scan_token(RBL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_29()) jj_scanpos = xsp;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3R_206() {
    if (jj_3R_224()) return true;
    return false;
  }

  private boolean jj_3R_295() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_294()) return true;
    return false;
  }

  private boolean jj_3R_284() {
    if (jj_3R_294()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_295()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_262() {
    if (jj_scan_token(CARE)) return true;
    if (jj_3R_251()) return true;
    return false;
  }

  private boolean jj_3R_205() {
    if (jj_scan_token(BREAK)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3_32() {
    if (jj_scan_token(RBL)) return true;
    if (jj_3R_44()) return true;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3R_251() {
    if (jj_3R_261()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_262()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_19() {
    if (jj_3R_32()) return true;
    return false;
  }

  private boolean jj_3R_204() {
    if (jj_scan_token(CONTINUE)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_149() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_32()) {
    jj_scanpos = xsp;
    if (jj_3R_199()) {
    jj_scanpos = xsp;
    if (jj_3R_200()) return true;
    }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_234()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_143() {
    if (jj_3R_32()) return true;
    return false;
  }

  private boolean jj_3R_203() {
    if (jj_scan_token(GOTO)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3_18() {
    if (jj_3R_32()) return true;
    return false;
  }

  private boolean jj_3R_96() {
    if (jj_3R_131()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_143()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_269() {
    if (jj_scan_token(AMP)) return true;
    if (jj_3R_261()) return true;
    return false;
  }

  private boolean jj_3R_158() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_203()) {
    jj_scanpos = xsp;
    if (jj_3R_204()) {
    jj_scanpos = xsp;
    if (jj_3R_205()) {
    jj_scanpos = xsp;
    if (jj_3R_206()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_33() {
    if (jj_3R_32()) return true;
    return false;
  }

  private boolean jj_3R_261() {
    if (jj_3R_268()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_269()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_20() {
    if (jj_3R_27()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_33()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_32() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_20()) {
    jj_scanpos = xsp;
    if (jj_3R_96()) return true;
    }
    return false;
  }

  private boolean jj_3R_283() {
    if (jj_scan_token(NE)) return true;
    return false;
  }

  private boolean jj_3R_282() {
    if (jj_scan_token(EQ)) return true;
    return false;
  }

  private boolean jj_3R_279() {
    if (jj_3R_212()) return true;
    return false;
  }

  private boolean jj_3R_95() {
    if (jj_3R_142()) return true;
    return false;
  }

  private boolean jj_3R_273() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_282()) {
    jj_scanpos = xsp;
    if (jj_3R_283()) return true;
    }
    if (jj_3R_268()) return true;
    return false;
  }

  private boolean jj_3R_287() {
    if (jj_3R_212()) return true;
    return false;
  }

  private boolean jj_3R_276() {
    if (jj_3R_284()) return true;
    return false;
  }

  private boolean jj_3R_268() {
    if (jj_3R_272()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_273()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_286() {
    if (jj_3R_212()) return true;
    return false;
  }

  private boolean jj_3_17() {
    if (jj_3R_32()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_276()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_278() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_286()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    xsp = jj_scanpos;
    if (jj_3R_287()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_42() {
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3R_285() {
    if (jj_3R_212()) return true;
    return false;
  }

  private boolean jj_3R_31() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_17()) {
    jj_scanpos = xsp;
    if (jj_3R_95()) return true;
    }
    return false;
  }

  private boolean jj_3R_277() {
    if (jj_3R_49()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_285()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_293() {
    if (jj_scan_token(GE)) return true;
    return false;
  }

  private boolean jj_3R_292() {
    if (jj_scan_token(LE)) return true;
    return false;
  }

  private boolean jj_3R_291() {
    if (jj_scan_token(GREATER)) return true;
    return false;
  }

  private boolean jj_3R_148() {
    if (jj_3R_43()) return true;
    return false;
  }

  private boolean jj_3R_290() {
    if (jj_scan_token(LESS)) return true;
    return false;
  }

  private boolean jj_3R_157() {
    if (jj_scan_token(FOR)) return true;
    if (jj_scan_token(RBL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_277()) {
    jj_scanpos = xsp;
    if (jj_3R_278()) return true;
    }
    if (jj_scan_token(SEMICOLON)) return true;
    xsp = jj_scanpos;
    if (jj_3R_279()) jj_scanpos = xsp;
    if (jj_scan_token(RBR)) return true;
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3R_104() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_148()) jj_scanpos = xsp;
    if (jj_3R_149()) return true;
    return false;
  }

  private boolean jj_3_16() {
    if (jj_3R_31()) return true;
    return false;
  }

  private boolean jj_3_28() {
    if (jj_3R_43()) return true;
    return false;
  }

  private boolean jj_3R_30() {
    Token xsp;
    if (jj_3_16()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_16()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_281() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_290()) {
    jj_scanpos = xsp;
    if (jj_3R_291()) {
    jj_scanpos = xsp;
    if (jj_3R_292()) {
    jj_scanpos = xsp;
    if (jj_3R_293()) return true;
    }
    }
    }
    if (jj_3R_272()) return true;
    return false;
  }

  private boolean jj_3R_272() {
    if (jj_3R_280()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_281()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_44() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_28()) {
    jj_scanpos = xsp;
    if (jj_3R_104()) return true;
    }
    return false;
  }

  private boolean jj_3R_218() {
    if (jj_scan_token(UNION)) return true;
    return false;
  }

  private boolean jj_3R_217() {
    if (jj_scan_token(STRUCT)) return true;
    return false;
  }

  private boolean jj_3R_192() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_217()) {
    jj_scanpos = xsp;
    if (jj_3R_218()) return true;
    }
    return false;
  }

  private boolean jj_3R_56() {
    if (jj_3R_44()) return true;
    return false;
  }

  private boolean jj_3R_20() {
    if (jj_3R_32()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_56()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_300() {
    if (jj_scan_token(RSH)) return true;
    return false;
  }

  private boolean jj_3R_156() {
    if (jj_scan_token(DO)) return true;
    if (jj_3R_50()) return true;
    if (jj_scan_token(WHILE)) return true;
    if (jj_scan_token(RBL)) return true;
    if (jj_3R_212()) return true;
    if (jj_scan_token(RBR)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_299() {
    if (jj_scan_token(LSH)) return true;
    return false;
  }

  private boolean jj_3R_193() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_289() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_299()) {
    jj_scanpos = xsp;
    if (jj_3R_300()) return true;
    }
    if (jj_3R_280()) return true;
    return false;
  }

  private boolean jj_3R_250() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  /** User defined Token Manager. */
  public TokenManager token_source;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  /** Whether we are looking ahead. */
  private boolean jj_lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[103];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x102,0x200,0x302,0x0,0x20000,0x0,0x0,0x0,0x302,0x0,0x702,0x400,0x0,0x702,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x702,0x0,0x0,0x0,0x0,0x40400800,0x88008000,0x0,0x0,0x40400800,0x30a84000,0x0,0x0,0x0,0x0,0x0,0x80008000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80008000,0x8000000,0x702,0x0,0x0,0x0,0x80008000,0x80008000,0x702,0x0,0x0,0x0,0x0,0x80008000,0x0,0x80008000,0x0,0x0,0x0,0x0,0x0,0x0,0x80008000,0x80008000,0x0,0x80008702,0x0,0x0,0x80008000,0x80008000,0x0,0x80008702,0x0,0x0,0x702,0x0,0x0,0x0,0x7051702,0x22000,0x7073702,0x702,0x702,0x702,0x702,0x702,0x702,0x2011000,0x702,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x20420000,0x0,0x0,0x0,0x26000000,0x26000000,0x20420000,0x0,0x26420008,0x6000008,0x0,0x26420008,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x10000000,0x0,0x26420008,0x0,0x0,0x20400000,0x100000,0x200090,0x86800,0x0,0x0,0x200090,0x1c726,0x400000,0x400000,0x120,0x20400000,0x100000,0x4800,0x0,0x0,0x20400000,0x400000,0x0,0x400000,0x0,0x4800,0x80000,0x26420008,0x0,0x20400000,0x20000000,0x4800,0x4800,0x26420008,0x10,0x400000,0x0,0x20000000,0x4800,0x0,0x4800,0x0,0x20000000,0x0,0x20000000,0x0,0x20000000,0x4800,0x4800,0x10,0x26424808,0x20000000,0x20000000,0x4800,0x4800,0x10,0x26424808,0x20000000,0x0,0xa6420008,0x0,0x0,0x0,0xa6421049,0x400000,0xa6421049,0x26420008,0x26420008,0x26420008,0x26420008,0x26420008,0x26420008,0x1,0x26420008,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x4000,0x0,0x4000,0x240002,0x240002,0x0,0x4000,0xbc8,0xbc8,0xbc8,0xbc8,0x38,0x38,0xc0,0xc0,0xc00000,0xc00000,0x3180000,0x3180000,0xc000000,0xc000000,0x200,0x1000,0x2000,0x0,0x0,0x400,0xbc8,0xf0020000,0x4000,0x8,0x0,0x0,0x0,0x4000,0x20000,0x0,0x0,0x0,0x0,0x0,0x10008,0x0,0x0,0x4000,0x10000,0x10008,0x0,0x4000,0x0,0x20000,0x0,0x0,0xbc8,0x8,0x0,0x2,0x0,0x0,0xbc8,0x0,0x0,0x2,0x0,0x0,0x8,0x0,0x4000,0xa,0x4000,0xa,0x8,0xa,0x0,0x0,0x0,0xbc8,0x2,0x2,0x0,0x0,0x0,0xbc8,0x2,0x4000,0xbc8,0x40002,0x40002,0x40002,0x8bc8,0x0,0x8bc8,0xbc8,0xbc8,0xbc8,0xbc8,0x8bc8,0xbc8,0x0,0xbc8,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[48];
  private boolean jj_rescan = false;
  private int jj_gc = 0;


  /** Constructor with user supplied Token Manager. */
  public DebugCParser(TokenManager tm) {
    token_source = tm;
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 103; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(TokenManager tm) {
    token_source = tm;
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 103; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken = token;
    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
    else jj_nt = jj_nt.next = token_source.getNextToken();
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      trace_token(token, "");
      return token;
    }
    jj_nt = token;
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
    else jj_nt = jj_nt.next = token_source.getNextToken();
    jj_gen++;
      trace_token(token, " (in getNextToken)");
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = jj_lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[103];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 103; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 103; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  private int trace_indent = 0;
  private boolean trace_enabled = true;

/** Enable tracing. */
  final public void enable_tracing() {
    trace_enabled = true;
  }

/** Disable tracing. */
  final public void disable_tracing() {
    trace_enabled = false;
  }

  private void trace_call(String s) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Call:   " + s);
    }
    trace_indent = trace_indent + 2;
  }

  private void trace_return(String s) {
    trace_indent = trace_indent - 2;
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Return: " + s);
    }
  }

  private void trace_token(Token t, String where) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Consumed token: <" + tokenImage[t.kind]);
      if (t.kind != 0 && !tokenImage[t.kind].equals("\"" + t.image + "\"")) {
        System.out.print(": \"" + t.image + "\"");
      }
      System.out.println(" at line " + t.beginLine + " column " + t.beginColumn + ">" + where);
    }
  }

  private void trace_scan(Token t1, int t2) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Visited token: <" + tokenImage[t1.kind]);
      if (t1.kind != 0 && !tokenImage[t1.kind].equals("\"" + t1.image + "\"")) {
        System.out.print(": \"" + t1.image + "\"");
      }
      System.out.println(" at line " + t1.beginLine + " column " + t1.beginColumn + ">; Expected token: <" + tokenImage[t2] + ">");
    }
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 48; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
            case 27: jj_3_28(); break;
            case 28: jj_3_29(); break;
            case 29: jj_3_30(); break;
            case 30: jj_3_31(); break;
            case 31: jj_3_32(); break;
            case 32: jj_3_33(); break;
            case 33: jj_3_34(); break;
            case 34: jj_3_35(); break;
            case 35: jj_3_36(); break;
            case 36: jj_3_37(); break;
            case 37: jj_3_38(); break;
            case 38: jj_3_39(); break;
            case 39: jj_3_40(); break;
            case 40: jj_3_41(); break;
            case 41: jj_3_42(); break;
            case 42: jj_3_43(); break;
            case 43: jj_3_44(); break;
            case 44: jj_3_45(); break;
            case 45: jj_3_46(); break;
            case 46: jj_3_47(); break;
            case 47: jj_3_48(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}

class DebugJTBToolkit {
   static NodeToken makeNodeToken(Token t) {
      NodeToken n = new NodeToken(t.image.intern(), t.kind, t.beginLine, t.beginColumn, t.endLine, t.endColumn);
        n.beginOffset = t.beginOffset;
        n.endOffset = t.endOffset;
        return n;
   }
}
